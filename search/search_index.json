{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Wire Cell","title":"Overview"},{"location":"#welcome-to-wire-cell","text":"","title":"Welcome to Wire Cell"},{"location":"alg/blob/","text":"","title":"Blob Reconstruction"},{"location":"alg/cell/","text":"","title":"Making Cells"},{"location":"dev/data/","text":"Wire Cell has a simple ROOT I/O persistency module. Schema The data is saved to several ROOT TFiles is shown in the following figure. Refer to the terms section for a nomenclature. ([ PNG ], [ PDF ], [ DOT ] and [ SVG ]) Generalities To store the data into a ROOT file we must take care of ownership and references explicitly. In general this is handled by representing ownership as an array of objects and references as an index into this array. There are three trees: Geometry, Channel and Cell. Geometry The geometry is saved into a tree with a single entry. There are three owning arrays, WireStore , PointStore and TilingStore owning: Wire with associated channel ID number (referred to in the Channel data tree) and two end points Point all 3d Points referred to by other objects. Cell associates a Wire via it's index ( wid ) with a center point and an (ordered) array of points that make up the corners of the cell. Channel Information about charge read out from all channels in a frame. One entry in this branch spans an entire readout frame. ChannelStore holds all channel data for the frame ChannelSlice associates a time bin tbin that counts relative to the start of the frame with a collection of read out channel charges. A negative charge is undefined. ChannelCharge associates a channel ID with a charge. Cell The Cell branch holds associations between charge and cells and groups of cells. This branch may hold MC truth value or reconstruction. CellCharge associates a cell ID, which is an index into the TilingStore with a charge. A negative charge is undefined. Blob owns an array of CellCharge . The technique is a user defined string to label the origin of the blob (eg, \"simtruth\" or maybe \"2dtoyreco\", etc). The tbin counts the time bin from the beginning of the frame, the qtot is some measure of the charge for the blob as a whole (and may not necessarily be the sum of the charge on the individual cells). The quality is a technique -specific measure of quality and finally the array of cell charge. BlobCluster is a (non-owning) association of blobs. This may be used to collect blobs together within one time slice or may be used to collect them together across multiple time slices such as to form the blobs contributing to a track or a shower. Blobs are referenced by their index into the frame's BlobStore . All available BlobClusters are stored in the ClusterStore","title":"Persistency"},{"location":"dev/data/#schema","text":"The data is saved to several ROOT TFiles is shown in the following figure. Refer to the terms section for a nomenclature. ([ PNG ], [ PDF ], [ DOT ] and [ SVG ])","title":"Schema"},{"location":"dev/data/#generalities","text":"To store the data into a ROOT file we must take care of ownership and references explicitly. In general this is handled by representing ownership as an array of objects and references as an index into this array. There are three trees: Geometry, Channel and Cell.","title":"Generalities"},{"location":"dev/data/#geometry","text":"The geometry is saved into a tree with a single entry. There are three owning arrays, WireStore , PointStore and TilingStore owning: Wire with associated channel ID number (referred to in the Channel data tree) and two end points Point all 3d Points referred to by other objects. Cell associates a Wire via it's index ( wid ) with a center point and an (ordered) array of points that make up the corners of the cell.","title":"Geometry"},{"location":"dev/data/#channel","text":"Information about charge read out from all channels in a frame. One entry in this branch spans an entire readout frame. ChannelStore holds all channel data for the frame ChannelSlice associates a time bin tbin that counts relative to the start of the frame with a collection of read out channel charges. A negative charge is undefined. ChannelCharge associates a channel ID with a charge.","title":"Channel"},{"location":"dev/data/#cell","text":"The Cell branch holds associations between charge and cells and groups of cells. This branch may hold MC truth value or reconstruction. CellCharge associates a cell ID, which is an index into the TilingStore with a charge. A negative charge is undefined. Blob owns an array of CellCharge . The technique is a user defined string to label the origin of the blob (eg, \"simtruth\" or maybe \"2dtoyreco\", etc). The tbin counts the time bin from the beginning of the frame, the qtot is some measure of the charge for the blob as a whole (and may not necessarily be the sum of the charge on the individual cells). The quality is a technique -specific measure of quality and finally the array of cell charge. BlobCluster is a (non-owning) association of blobs. This may be used to collect blobs together within one time slice or may be used to collect them together across multiple time slices such as to form the blobs contributing to a track or a shower. Blobs are referenced by their index into the frame's BlobStore . All available BlobClusters are stored in the ClusterStore","title":"Cell"},{"location":"dev/dev/","text":"Build Dancing Debug New packages Considerations Source Package Conventions Build packages Namespaces Dealing with git submodules Here is what you will do in the act of developing code. Build Dancing To rebuild after hacking on the source just type: $ waf When ready to install into the configured \u201cprefix\u201d installation area: $ waf install To force a full rebuild: $ waf clean build To limit building to just one submodule: $ cd <subdir>/ $ waf Debug To build for debugging one needs to reconfigure waf with a --build-debug=<flags> option and then the project must be cleaned and rebuilt. This can be done all at once like: $ waf --prefix=/path/to/install --build-debug=-ggdb3 clean configure build install You may also want to see what commands Waf is actually running to confirm this option is transmitted, just add a -v to the command line: $ waf -v Finally, run GDB in your usual, preferred manner: $ gdb --args /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource (gdb) run New packages New wire-cell packages can be added easily. Considerations Wire Cell packages are organized to be easy to create. It's much better to create many small packages and maybe later merge them than it is to split apart ones which have grown too monolithic. When thinking about writing some code consider What other packages will I need? What future packages will need mine? You may have an idea for a package but in reality it is better split up into others. Here are reasons to believe your ideas fit into multiple packages: When I describe my expected package functionality I use the word \"and\". Some other package should use part of my package but the other part is not needed. If in doubt, make more, smaller packages. Source Package Conventions To make them easy to build and aggregate they must follow a layout convention. First, each source package should be kept in it's own git repository. The recommended package naming convention is: wire-cell-NAME where NAME is some short identifier of the package's primary purpose. The contents of the source package must be organized following these sub-directory conventions src/ # C++ source file for libraries with .cxx extensions or private headers inc/NAME/ # public/API C++ header files with .h extensions dict/LinkDef.h # ROOT linkdef header (for rootcling dictionaries) tests/ # Unit tests Python (nosetests) files like test_*.py or main C++ programs named like test_*.cxx. apps/ # main application(s), one appname.cxx file for each app named appname (todo: not yet supported) python/NAME # python modules (todo: not yet supported) wscript_build # a brief waf file The wscript_build file specifies a name for the binary package (in general similar but not identical to the source package name) and a list of any other packages part of the wire-cell system on which it depends. For example the wire-cell-nav source package builds to a WireCellNav binary package and it depends on the WireCellData package and so its wscript_build file is: bld.make_package('WireCellNav', use='WireCellData') This is Python and the bld object is a Waf build context. It is provided automagically when waf interprets this file. Build packages The above is about code packages. Code packages are built via a build package. This build package, wire-cell is but one possible \"view\" into all the wire cell packages. Other build packages may be created which only build some sub-set of all wire cell packages. To add a new code package to a build package (such as this one) one must do a little, annoying dance: $ mkdir <name> $ cd <name>/ $ echo \"bld.make_package('WireCell<Name>', use='WireCellNav WireCellData')\" > wscript_build $ git init $ git commit -a -m \"Start code package <name>\" Replace <name> with your package name. And, of course, you may want to put more code than just the wscript_build file. Also, that file should list what packages your package depends on. Now, make a new repository by going to the BNLIF GitHub and clicking \"New repository\" button. Give it a name like wire-cell-<name> . Copy-and-paste the two command it tells you to use: $ git remote add origin git@github.com:BNLIF/wire-cell-<name>.git $ git push -u origin master Finally, move aside the local repository and add it right back as a submodule: $ cd .. # back to top $ mv <name> <name>.moved $ git submodule add -- git@github.com:BNLIF/wire-cell-<name>.git <name> $ git submodule update $ git commit -a -m \"Added <name> to top-level build package.\" $ git push Whew! Namespaces The namespace WireCell is used for all \"core\" wire cell code. Code that is used to glue this core functionality into other systems may use another namespace but should not use WireCell. For example, the \"simple simulation tree\" uses WireCellSst . It can be tedious to type explicit namespace qualifiers all the time. You can use the using namespace WireCell; directive where in implementation files (*.cxx) but you should never use it in (top-scope) of header files as it will then leak the contents of the namespace into any unsuspecting file that #include\u2019s it. Dealing with git submodules From the git book , do you updates like: $ git submodule update --remote --rebase or like $ git submodule update --remote --merge With: --rebase : put our local commits on top of any new ones --merge : merge our commits into new ones The first leaves a more \"linear\" commit history while the second leaves \"diamonds\" in the history whenever we have briefly diverged from the remote repository. You can run \" gitk --all \" in wire-cell or one of the submodules to see what I mean. Either way is fine. Rebasing looks cleaner in the history but merge captures the subtle fact of where our line of development actually diverged. In that link there are other interesting things to do: Configure your repository so \" git status \" in the top-level \"wire-cell\" gives us more info on the status of all submodules: $ git config status.submodulesummary 1 Make it so \" git diff \" in wire-cell will also show any diff's in the submodules: $ git config diff.submodule log To check that we will push in the right order (submodules first): $ git push --recurse-submodules=check To force submodules to push first $ git push --recurse-submodules=on-demand To run any command in all submodules $ git submodule foreach 'the command'","title":"Building"},{"location":"dev/dev/#build-dancing","text":"To rebuild after hacking on the source just type: $ waf When ready to install into the configured \u201cprefix\u201d installation area: $ waf install To force a full rebuild: $ waf clean build To limit building to just one submodule: $ cd <subdir>/ $ waf","title":"Build Dancing"},{"location":"dev/dev/#debug","text":"To build for debugging one needs to reconfigure waf with a --build-debug=<flags> option and then the project must be cleaned and rebuilt. This can be done all at once like: $ waf --prefix=/path/to/install --build-debug=-ggdb3 clean configure build install You may also want to see what commands Waf is actually running to confirm this option is transmitted, just add a -v to the command line: $ waf -v Finally, run GDB in your usual, preferred manner: $ gdb --args /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource (gdb) run","title":"Debug"},{"location":"dev/dev/#new-packages","text":"New wire-cell packages can be added easily.","title":"New packages"},{"location":"dev/dev/#considerations","text":"Wire Cell packages are organized to be easy to create. It's much better to create many small packages and maybe later merge them than it is to split apart ones which have grown too monolithic. When thinking about writing some code consider What other packages will I need? What future packages will need mine? You may have an idea for a package but in reality it is better split up into others. Here are reasons to believe your ideas fit into multiple packages: When I describe my expected package functionality I use the word \"and\". Some other package should use part of my package but the other part is not needed. If in doubt, make more, smaller packages.","title":"Considerations"},{"location":"dev/dev/#source-package-conventions","text":"To make them easy to build and aggregate they must follow a layout convention. First, each source package should be kept in it's own git repository. The recommended package naming convention is: wire-cell-NAME where NAME is some short identifier of the package's primary purpose. The contents of the source package must be organized following these sub-directory conventions src/ # C++ source file for libraries with .cxx extensions or private headers inc/NAME/ # public/API C++ header files with .h extensions dict/LinkDef.h # ROOT linkdef header (for rootcling dictionaries) tests/ # Unit tests Python (nosetests) files like test_*.py or main C++ programs named like test_*.cxx. apps/ # main application(s), one appname.cxx file for each app named appname (todo: not yet supported) python/NAME # python modules (todo: not yet supported) wscript_build # a brief waf file The wscript_build file specifies a name for the binary package (in general similar but not identical to the source package name) and a list of any other packages part of the wire-cell system on which it depends. For example the wire-cell-nav source package builds to a WireCellNav binary package and it depends on the WireCellData package and so its wscript_build file is: bld.make_package('WireCellNav', use='WireCellData') This is Python and the bld object is a Waf build context. It is provided automagically when waf interprets this file.","title":"Source Package Conventions"},{"location":"dev/dev/#build-packages","text":"The above is about code packages. Code packages are built via a build package. This build package, wire-cell is but one possible \"view\" into all the wire cell packages. Other build packages may be created which only build some sub-set of all wire cell packages. To add a new code package to a build package (such as this one) one must do a little, annoying dance: $ mkdir <name> $ cd <name>/ $ echo \"bld.make_package('WireCell<Name>', use='WireCellNav WireCellData')\" > wscript_build $ git init $ git commit -a -m \"Start code package <name>\" Replace <name> with your package name. And, of course, you may want to put more code than just the wscript_build file. Also, that file should list what packages your package depends on. Now, make a new repository by going to the BNLIF GitHub and clicking \"New repository\" button. Give it a name like wire-cell-<name> . Copy-and-paste the two command it tells you to use: $ git remote add origin git@github.com:BNLIF/wire-cell-<name>.git $ git push -u origin master Finally, move aside the local repository and add it right back as a submodule: $ cd .. # back to top $ mv <name> <name>.moved $ git submodule add -- git@github.com:BNLIF/wire-cell-<name>.git <name> $ git submodule update $ git commit -a -m \"Added <name> to top-level build package.\" $ git push Whew!","title":"Build packages"},{"location":"dev/dev/#namespaces","text":"The namespace WireCell is used for all \"core\" wire cell code. Code that is used to glue this core functionality into other systems may use another namespace but should not use WireCell. For example, the \"simple simulation tree\" uses WireCellSst . It can be tedious to type explicit namespace qualifiers all the time. You can use the using namespace WireCell; directive where in implementation files (*.cxx) but you should never use it in (top-scope) of header files as it will then leak the contents of the namespace into any unsuspecting file that #include\u2019s it.","title":"Namespaces"},{"location":"dev/dev/#dealing-with-git-submodules","text":"From the git book , do you updates like: $ git submodule update --remote --rebase or like $ git submodule update --remote --merge With: --rebase : put our local commits on top of any new ones --merge : merge our commits into new ones The first leaves a more \"linear\" commit history while the second leaves \"diamonds\" in the history whenever we have briefly diverged from the remote repository. You can run \" gitk --all \" in wire-cell or one of the submodules to see what I mean. Either way is fine. Rebasing looks cleaner in the history but merge captures the subtle fact of where our line of development actually diverged. In that link there are other interesting things to do: Configure your repository so \" git status \" in the top-level \"wire-cell\" gives us more info on the status of all submodules: $ git config status.submodulesummary 1 Make it so \" git diff \" in wire-cell will also show any diff's in the submodules: $ git config diff.submodule log To check that we will push in the right order (submodules first): $ git push --recurse-submodules=check To force submodules to push first $ git push --recurse-submodules=on-demand To run any command in all submodules $ git submodule foreach 'the command'","title":"Dealing with git submodules"},{"location":"dev/iface/","text":"Wire Cell uses Interfaces to access major components. Overview of Interfaces Wire Cell has a number of high-level concepts which are implemented as C++ \"Interface\" classes. Such classes expose only methods which take or return either Plain Old Data (POD) or instances from the Wire Cell Data package. The reason for this additional layer is to provide a decoupling between the different Wire Cell packages and to allow one to set actual implementations at the application layer. This allows for competing implementations to be swapped in a transparent manner. For example, one may have a wire geometry that comes from a parameterized model that generates wire placements or one may have a detailed as-is survey where each wire is painstakingly described and stored. The code that uses such a geometry doesn't care and instead accesses whatever the application layer gives it via the IWireGeometry interface. A concrete implementation may present multiple interfaces. For example the GeomDataSource from the Wire Cell Nav package provides both IWireGeometry and IWireDatabase interfaces. Providing Interfaces Interface classes provide a mechanism to keep packages independent and loosely coupled. It does this by having code depend only on the generic interface classes and not on the concrete implementations. It is possible (and easy) to violate paradigm and end up back with tightly coupled packages and code. This unwanted tight coupling can still occur if the code that produces the concrete implementation of an interface is intermixed with the code that consumes the interface. To combat this one should layer the packages so that a higher application layer is responsible for creating the concrete implementations of interfaces as well as the consumer code (which may also be accessed through interfaces). Specifically, to maintain this separation one should place any apps/*.cxx and tests/*.cxx main programs which create concrete implementations of interfaces in a package other than the one that holds the generic src/*.cxx library files. Context There are various important interfaces that most all of Wire Cell code will require. It is thus convenient to bundle access to these into a single interface called the IContext . This simplifies high-level application code as the code for creating and initializing a specific context can be provided as a high-level library. For example, all geometry and readout data may come from some domain. One example is if the input to Wire Cell originates from Wire Cell SST files. High-level application code can depend on SST, produce an SST-based context and feed its content to the Wire Cell code as generic interfaces. Example The figure below gives a hypothetical example. At the top are the Wire Cell interfaces. In the middle are the concrete implementations of these interfaces. At the very bottom are (paradoxically) high-level application components which aggregate concrete implementations together in order to drive the program. Shown is an example of how Wire Cell and LArSoft might integrate. A wire-cell-larsoft component would provide concrete implementations of Wire Cell interfaces using code that depends on facilities from LArSoft. A high-level (at the bottom) \"application\" (an Art module) would tie together the interfaces implemented by LArSoft code and the Wire Cell implementation in order to run in an Art job.","title":"Interfaces"},{"location":"dev/iface/#overview-of-interfaces","text":"Wire Cell has a number of high-level concepts which are implemented as C++ \"Interface\" classes. Such classes expose only methods which take or return either Plain Old Data (POD) or instances from the Wire Cell Data package. The reason for this additional layer is to provide a decoupling between the different Wire Cell packages and to allow one to set actual implementations at the application layer. This allows for competing implementations to be swapped in a transparent manner. For example, one may have a wire geometry that comes from a parameterized model that generates wire placements or one may have a detailed as-is survey where each wire is painstakingly described and stored. The code that uses such a geometry doesn't care and instead accesses whatever the application layer gives it via the IWireGeometry interface. A concrete implementation may present multiple interfaces. For example the GeomDataSource from the Wire Cell Nav package provides both IWireGeometry and IWireDatabase interfaces.","title":"Overview of Interfaces"},{"location":"dev/iface/#providing-interfaces","text":"Interface classes provide a mechanism to keep packages independent and loosely coupled. It does this by having code depend only on the generic interface classes and not on the concrete implementations. It is possible (and easy) to violate paradigm and end up back with tightly coupled packages and code. This unwanted tight coupling can still occur if the code that produces the concrete implementation of an interface is intermixed with the code that consumes the interface. To combat this one should layer the packages so that a higher application layer is responsible for creating the concrete implementations of interfaces as well as the consumer code (which may also be accessed through interfaces). Specifically, to maintain this separation one should place any apps/*.cxx and tests/*.cxx main programs which create concrete implementations of interfaces in a package other than the one that holds the generic src/*.cxx library files.","title":"Providing Interfaces"},{"location":"dev/iface/#context","text":"There are various important interfaces that most all of Wire Cell code will require. It is thus convenient to bundle access to these into a single interface called the IContext . This simplifies high-level application code as the code for creating and initializing a specific context can be provided as a high-level library. For example, all geometry and readout data may come from some domain. One example is if the input to Wire Cell originates from Wire Cell SST files. High-level application code can depend on SST, produce an SST-based context and feed its content to the Wire Cell code as generic interfaces.","title":"Context"},{"location":"dev/iface/#example","text":"The figure below gives a hypothetical example. At the top are the Wire Cell interfaces. In the middle are the concrete implementations of these interfaces. At the very bottom are (paradoxically) high-level application components which aggregate concrete implementations together in order to drive the program. Shown is an example of how Wire Cell and LArSoft might integrate. A wire-cell-larsoft component would provide concrete implementations of Wire Cell interfaces using code that depends on facilities from LArSoft. A high-level (at the bottom) \"application\" (an Art module) would tie together the interfaces implemented by LArSoft code and the Wire Cell implementation in order to run in an Art job.","title":"Example"},{"location":"dev/overview/","text":"An overview of the system with indications of current status and near term plans is given as a diagram below. ([ PNG ], [ PDF ], [ DOT ] and for clickable links open [ SVG ]) The legend for this diagram is: dotted line : this step is missing and needed. dashed line : this step exists but is not captured so that anyone can perform it. solid line : this step exists, documented to some extent and anyone can reproduce it (eg, it's in GitHub). yellow : this process exists but is not generally known/available. red : this process does not exist or is just conceptual and is needed soon. folder shape : some file or file types component shape : some software package rectangle shape : a program trapezoid shape : visualization or end-user application Terms These terms are used with specific meanings in Wire Cell coordinate system : electrons drift in the negative-X direction toward the wire planes, Y points upward and is sometimes referred to as W, Z follows from the right-hand-rule. U and V directions point at some angle w.r.t. W and are in the W-Z plane. tick : the unit of digitized time. tbin : one bin of time of some integral number of ticks wire plane : a two-dimensional extent in the Y-Z plane which is perpendicular to the drift direction. There is a U, V and W (aka Y) wire plane which contains wire segments. Each of these planes are slightly offset in the drift direction X. charge : refers to an amount of charged particles drifting past the wire plane during one tick. Sometimes used to refer to the deconvolved ADC in one tick which provides a measure of the charge. Sometimes used to refer to the un-deconvolved signal. Yes, it's confusing. wire : a segment or run of the conductor which senses the passing of drifting charge. A wire runs in either the U, V or W (aka Y) direction. channel : the unit of electronics responsible for digitizing charge on a wire. For detectors with wrapped readout conductors a single channel maps to multiple wires. cell : a region of the plane surrounding an area near where three wires, one from each plane, are crossing (at least pairwise, if not in a triple-point). tiling : the set of cells which fully cover the plane with no gaps nor overlaps. There is more than one way to tile the plane. blob : an association of continguous cells which is expected to contain a portion of the charge of the event from one tbin. In general, the association will include cells which may not actually contain charge. A blob is bounded by cells (or plane boundaries) which definitely do not contain charge. blob cluster : an association of a number of blobs, potentially from different tbins, which intend to capture an extended portion of charge that came from the passage of a single particle (track) or multiple, closely related particles (shower). slice : a qualifier to indicate information from one tbin. A wire slice would indicate the collection of charge collected on wires at a given time. frame : the collection of slices readout as a continuous unit from the DAQ.","title":"Overview"},{"location":"dev/overview/#terms","text":"These terms are used with specific meanings in Wire Cell coordinate system : electrons drift in the negative-X direction toward the wire planes, Y points upward and is sometimes referred to as W, Z follows from the right-hand-rule. U and V directions point at some angle w.r.t. W and are in the W-Z plane. tick : the unit of digitized time. tbin : one bin of time of some integral number of ticks wire plane : a two-dimensional extent in the Y-Z plane which is perpendicular to the drift direction. There is a U, V and W (aka Y) wire plane which contains wire segments. Each of these planes are slightly offset in the drift direction X. charge : refers to an amount of charged particles drifting past the wire plane during one tick. Sometimes used to refer to the deconvolved ADC in one tick which provides a measure of the charge. Sometimes used to refer to the un-deconvolved signal. Yes, it's confusing. wire : a segment or run of the conductor which senses the passing of drifting charge. A wire runs in either the U, V or W (aka Y) direction. channel : the unit of electronics responsible for digitizing charge on a wire. For detectors with wrapped readout conductors a single channel maps to multiple wires. cell : a region of the plane surrounding an area near where three wires, one from each plane, are crossing (at least pairwise, if not in a triple-point). tiling : the set of cells which fully cover the plane with no gaps nor overlaps. There is more than one way to tile the plane. blob : an association of continguous cells which is expected to contain a portion of the charge of the event from one tbin. In general, the association will include cells which may not actually contain charge. A blob is bounded by cells (or plane boundaries) which definitely do not contain charge. blob cluster : an association of a number of blobs, potentially from different tbins, which intend to capture an extended portion of charge that came from the passage of a single particle (track) or multiple, closely related particles (shower). slice : a qualifier to indicate information from one tbin. A wire slice would indicate the collection of charge collected on wires at a given time. frame : the collection of slices readout as a continuous unit from the DAQ.","title":"Terms"},{"location":"dev/test/","text":"Tests Tests go under the test/ (or tests/ ) sub-directory of the package. There are two types, C++ and Python. In both cases, only files that begin with \" test_* \" will be considered tests. Tests are automatically run as part of the build procedure (fixme: just C++ ones are automatic right now) and will be rerun when they or code they depend on changes. When tests are run by the build the stdout/stderr is typically captured. You can run them manually to observe any print statements. Tests are not installed but left in the \" build/ \" (or sometimes \" tmp/ \") output directory. Here are a few general guidelines for writing tests: write many tests write tests as fine grained as convenient the best tests are written before or while the code they test is being written test code does need not be \"pretty\", it will never be called from anywhere else tests should run quickly do use contrived data or mocked code to provide a bit of test code it's needed input or code support C++ tests Writing a C++ test is to write a main() program which takes no arguments . If a test fails, either let it crash the test program or call exit(1) . You can explicitly run C++ test programs. When they are run as part of the build, their full path is printed. When run automatically, waf takes care of setting up their environment so that their libraries are found. When run manually you will have to assure this. The simplest way is to waf install \" the package first. $ waf ... execution summary tests that pass 3/4 /home/bviren/projects/wire-cell/top/build/data/test_construct /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource /home/bviren/projects/wire-cell/top/build/sst/tgeomdatasource tests that fail 1/4 /home/bviren/projects/wire-cell/top/build/data/test_fail 'build' finished successfully $ waf install $ /home/bviren/projects/wire-cell/top/build/sst/test_sst_geomdatasource Wire: 0 plane=1 index=0 Wire: 0 plane=1 index=1 Wire: 0 plane=1 index=2 ...","title":"Testing"},{"location":"dev/test/#tests","text":"Tests go under the test/ (or tests/ ) sub-directory of the package. There are two types, C++ and Python. In both cases, only files that begin with \" test_* \" will be considered tests. Tests are automatically run as part of the build procedure (fixme: just C++ ones are automatic right now) and will be rerun when they or code they depend on changes. When tests are run by the build the stdout/stderr is typically captured. You can run them manually to observe any print statements. Tests are not installed but left in the \" build/ \" (or sometimes \" tmp/ \") output directory. Here are a few general guidelines for writing tests: write many tests write tests as fine grained as convenient the best tests are written before or while the code they test is being written test code does need not be \"pretty\", it will never be called from anywhere else tests should run quickly do use contrived data or mocked code to provide a bit of test code it's needed input or code support","title":"Tests"},{"location":"dev/test/#c-tests","text":"Writing a C++ test is to write a main() program which takes no arguments . If a test fails, either let it crash the test program or call exit(1) . You can explicitly run C++ test programs. When they are run as part of the build, their full path is printed. When run automatically, waf takes care of setting up their environment so that their libraries are found. When run manually you will have to assure this. The simplest way is to waf install \" the package first. $ waf ... execution summary tests that pass 3/4 /home/bviren/projects/wire-cell/top/build/data/test_construct /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource /home/bviren/projects/wire-cell/top/build/sst/tgeomdatasource tests that fail 1/4 /home/bviren/projects/wire-cell/top/build/data/test_fail 'build' finished successfully $ waf install $ /home/bviren/projects/wire-cell/top/build/sst/test_sst_geomdatasource Wire: 0 plane=1 index=0 Wire: 0 plane=1 index=1 Wire: 0 plane=1 index=2 ...","title":"C++ tests"},{"location":"install/external/","text":"Overview Manual installation of externals Compiler ROOT6 Automated installation with Spack Site installations RACF Setup FNAL Setup OS level installation Mac Overview The wire-cell software in BNL IF GitHub depends on some software that may not come with your OS, in particular ROOT v6 and a possibly a compiler that supports C++11. There are a few ways ways to supply the required externals described below. manually build or otherwise provide them yourself. automatically build and install them with Spack with support provided by the Wire Cell Toolkit's wire-cell-spack package. use an existing site-installation. OS-level installation. The following sections gives some guidance on each of these approaches. Manual installation of externals You may provide Wire Cell externals as you wish. This section gives guidance on how to do this. Some general things to assure: use the same compiler for all C++ packages. use a compiler that supports C++11. all C++ packages built against the C++11 standard, eg GCC's -std=c++11 flag. The rest of this section gives some guidance on specific packages. Compiler You must use a compiler that supports C++11. Clang may work but is untested (please report successes/failures). GCC 4.9.2 is what the developers currently use. Newer GCCs are more strict, particularly w.r.t. headers will likely uncover bugs of omission. Please report them to the developers. ROOT6 CMake should used with at least these flags: cmake -Dminuit2=ON -Dpython=ON -Dcxx11=ON -DFFTW_LIBRARY=/path/to/lib/libfftw3.so [...] Automated installation with Spack Spack is a \"meta build system\" that runs the individual build systems that come with packages. It allows one to manage an ever growing installation area which can accommodate multiple versions of a package. It also comes with support for Environment Modules to handle your users' setup of these packages or can make targeted release \"views\" of its package tree. The Wire Cell Toolkit provides a package wire-cell-spack which collects instructions and a Spack \"repo\" that builds WCT and its third-party dependencies. This leverages Spacks built-in \"repo\" to provide dependencies needed by WCT's direct dependencies. Using it will tend to build packages that one may already have installed through the OS (eg, Python). However, this duplication should not add much to the overall build time which is automatic nor lead to any problems. An installer that wishes to use wire-cell-spack to provide the dependencies should begin by following its README file. Although developed for the Wire Cell Toolkit, the resulting external dependencies will be suitable for the prototype. However, some additional packages not strictly required may be built. Site installations Some sites associated with Wire Cell development have already been provisioned with the necessary externals and you may leverage them. RACF Setup At BNL's RACF, a simple, single-rooted installation of Wire Cell external packages is provided. Bash users do: $ source /gpfs01/lbne/users/sw/wc/bin/thisroot.sh Or, if you are still stuck using tcsh do: > source /gpfs01/lbne/users/sw/wc/bin/thisroot.csh FNAL Setup At Fermilab, externals are provided by UPS. $ source /grid/fermiapp/products/larsoft/setups $ setup root v6_04_02 -q e7:prof $ setup boost v1_57_0 -q e7:prof OS level installation Mac Install homebrew and do $ brew install boost $ brew install homebrew/science/root6","title":"Install Externals"},{"location":"install/external/#overview","text":"The wire-cell software in BNL IF GitHub depends on some software that may not come with your OS, in particular ROOT v6 and a possibly a compiler that supports C++11. There are a few ways ways to supply the required externals described below. manually build or otherwise provide them yourself. automatically build and install them with Spack with support provided by the Wire Cell Toolkit's wire-cell-spack package. use an existing site-installation. OS-level installation. The following sections gives some guidance on each of these approaches.","title":"Overview"},{"location":"install/external/#manual-installation-of-externals","text":"You may provide Wire Cell externals as you wish. This section gives guidance on how to do this. Some general things to assure: use the same compiler for all C++ packages. use a compiler that supports C++11. all C++ packages built against the C++11 standard, eg GCC's -std=c++11 flag. The rest of this section gives some guidance on specific packages.","title":"Manual installation of externals"},{"location":"install/external/#compiler","text":"You must use a compiler that supports C++11. Clang may work but is untested (please report successes/failures). GCC 4.9.2 is what the developers currently use. Newer GCCs are more strict, particularly w.r.t. headers will likely uncover bugs of omission. Please report them to the developers.","title":"Compiler"},{"location":"install/external/#root6","text":"CMake should used with at least these flags: cmake -Dminuit2=ON -Dpython=ON -Dcxx11=ON -DFFTW_LIBRARY=/path/to/lib/libfftw3.so [...]","title":"ROOT6"},{"location":"install/external/#automated-installation-with-spack","text":"Spack is a \"meta build system\" that runs the individual build systems that come with packages. It allows one to manage an ever growing installation area which can accommodate multiple versions of a package. It also comes with support for Environment Modules to handle your users' setup of these packages or can make targeted release \"views\" of its package tree. The Wire Cell Toolkit provides a package wire-cell-spack which collects instructions and a Spack \"repo\" that builds WCT and its third-party dependencies. This leverages Spacks built-in \"repo\" to provide dependencies needed by WCT's direct dependencies. Using it will tend to build packages that one may already have installed through the OS (eg, Python). However, this duplication should not add much to the overall build time which is automatic nor lead to any problems. An installer that wishes to use wire-cell-spack to provide the dependencies should begin by following its README file. Although developed for the Wire Cell Toolkit, the resulting external dependencies will be suitable for the prototype. However, some additional packages not strictly required may be built.","title":"Automated installation with Spack"},{"location":"install/external/#site-installations","text":"Some sites associated with Wire Cell development have already been provisioned with the necessary externals and you may leverage them.","title":"Site installations"},{"location":"install/external/#racf-setup","text":"At BNL's RACF, a simple, single-rooted installation of Wire Cell external packages is provided. Bash users do: $ source /gpfs01/lbne/users/sw/wc/bin/thisroot.sh Or, if you are still stuck using tcsh do: > source /gpfs01/lbne/users/sw/wc/bin/thisroot.csh","title":"RACF Setup"},{"location":"install/external/#fnal-setup","text":"At Fermilab, externals are provided by UPS. $ source /grid/fermiapp/products/larsoft/setups $ setup root v6_04_02 -q e7:prof $ setup boost v1_57_0 -q e7:prof","title":"FNAL Setup"},{"location":"install/external/#os-level-installation","text":"","title":"OS level installation"},{"location":"install/external/#mac","text":"Install homebrew and do $ brew install boost $ brew install homebrew/science/root6","title":"Mac"},{"location":"install/install/","text":"Installation of prerequisites Preparing wire-cell source Building wire-cell Run-time environment Installation of prerequisites The Wire Cell prototype code requires at least: BOOST 1.55 (or equiv) ROOT v6 Python 2.7 (optional unless you want Python bindings) wire-cell-xdata-root (follow this instruction ) More information is available in the section Install Externals . You will need to set up your run-time environment so that these commands do not fail and give the expected version: $ root -b -q ... | Welcome to ROOT 6.05/01 http://root.cern.ch | ... $ python -c 'import ROOT; print ROOT.gROOT.GetVersion()' 6.05/01 Preparing wire-cell source Wire Cell is made up of several source packages. A top-level wire-cell package is used to aggregate them together as well as provide the top-level build environment. The aggregation is done using Git submodules. If you are a developer wanting to use SSH keys (default) to access the repository clone with the appropriate URL: $ git clone git@github.com:BNLIF/wire-cell.git $ cd wire-cell/ If you are anonymous or in any case prefer to use HTTPS instead of SSH you will need to clone as shown below and then convert the submodules to likewise use HTTPS via the provided script. $ git clone https://github.com/BNLIF/wire-cell.git $ cd wire-cell/ $ ./switch-git-urls Later, you can switch back to developer/SSH URLs with: $ ./switch-git-urls dev Now get the submodules: $ git submodule init $ git submodule update Finally, it is convenient to set an alias to the copy of waf. Otherwise you'll need to specify it's full path or make it available in your $PATH . $ alias waf=`pwd`/waf-tools/waf Building wire-cell To configure, build and install the wire cell code do: $ waf --prefix=/path/to/install configure build install If the external prerequisites are not automatically found by waf their locations can be set by some options. See waf --help . Run-time environment Set up your run time environment following whatever method you chose to supply the external packages. For wire-cell itself you will need to set or add to the usual: PATH LD_LIBRARY_PATH PYTHONPATH to point to directories under /path/to/install . Special notes: Ubuntu: :: Set PYTHONNOUSERSITE to yes (or anything) if you also have Ubuntu ROOT packages installed. This will stop the system PyROOT from being picked up Scientific Linux: :: the build currently installs to both lib/ and lib64/ directories so add both to your LD_LIBRARY_PATH . Install to single root: :: If you followed the single rooted install pattern and chose the /path/to/install to be coincident with /path/to/single-rooted then probably no additional user environment will be needed beyond sourcing ROOT's thisroot.sh .","title":"Install Wire Cell"},{"location":"install/install/#installation-of-prerequisites","text":"The Wire Cell prototype code requires at least: BOOST 1.55 (or equiv) ROOT v6 Python 2.7 (optional unless you want Python bindings) wire-cell-xdata-root (follow this instruction ) More information is available in the section Install Externals . You will need to set up your run-time environment so that these commands do not fail and give the expected version: $ root -b -q ... | Welcome to ROOT 6.05/01 http://root.cern.ch | ... $ python -c 'import ROOT; print ROOT.gROOT.GetVersion()' 6.05/01","title":"Installation of prerequisites"},{"location":"install/install/#preparing-wire-cell-source","text":"Wire Cell is made up of several source packages. A top-level wire-cell package is used to aggregate them together as well as provide the top-level build environment. The aggregation is done using Git submodules. If you are a developer wanting to use SSH keys (default) to access the repository clone with the appropriate URL: $ git clone git@github.com:BNLIF/wire-cell.git $ cd wire-cell/ If you are anonymous or in any case prefer to use HTTPS instead of SSH you will need to clone as shown below and then convert the submodules to likewise use HTTPS via the provided script. $ git clone https://github.com/BNLIF/wire-cell.git $ cd wire-cell/ $ ./switch-git-urls Later, you can switch back to developer/SSH URLs with: $ ./switch-git-urls dev Now get the submodules: $ git submodule init $ git submodule update Finally, it is convenient to set an alias to the copy of waf. Otherwise you'll need to specify it's full path or make it available in your $PATH . $ alias waf=`pwd`/waf-tools/waf","title":"Preparing wire-cell source"},{"location":"install/install/#building-wire-cell","text":"To configure, build and install the wire cell code do: $ waf --prefix=/path/to/install configure build install If the external prerequisites are not automatically found by waf their locations can be set by some options. See waf --help .","title":"Building wire-cell"},{"location":"install/install/#run-time-environment","text":"Set up your run time environment following whatever method you chose to supply the external packages. For wire-cell itself you will need to set or add to the usual: PATH LD_LIBRARY_PATH PYTHONPATH to point to directories under /path/to/install . Special notes: Ubuntu: :: Set PYTHONNOUSERSITE to yes (or anything) if you also have Ubuntu ROOT packages installed. This will stop the system PyROOT from being picked up Scientific Linux: :: the build currently installs to both lib/ and lib64/ directories so add both to your LD_LIBRARY_PATH . Install to single root: :: If you followed the single rooted install pattern and chose the /path/to/install to be coincident with /path/to/single-rooted then probably no additional user environment will be needed beyond sourcing ROOT's thisroot.sh .","title":"Run-time environment"},{"location":"meta/meta/","text":"About this site This site uses MkDocs and is served by GitHub. To edit $ git clone git@github.com:BNLIF/wire-cell-docs.git $ cd wire-cell-docs $ emacs $ git commit -a -m \"...\" $ git push To preview $ mkdocs serve INFO - Building documentation... [I 150708 17:57:26 server:271] Serving on http://127.0.0.1:8000 [I 150708 17:57:26 handlers:58] Start watching changes [I 150708 17:57:26 handlers:60] Start detecting changes Click on the link to view the result in your browser. As you continue to edit the server should notice the change, regenerate and trigger your browser to refresh. To deploy $ mkdocs gh-deploy --clean After a brief moment this will update the main docs site .","title":"About"},{"location":"meta/meta/#about-this-site","text":"This site uses MkDocs and is served by GitHub.","title":"About this site"},{"location":"meta/meta/#to-edit","text":"$ git clone git@github.com:BNLIF/wire-cell-docs.git $ cd wire-cell-docs $ emacs $ git commit -a -m \"...\" $ git push","title":"To edit"},{"location":"meta/meta/#to-preview","text":"$ mkdocs serve INFO - Building documentation... [I 150708 17:57:26 server:271] Serving on http://127.0.0.1:8000 [I 150708 17:57:26 handlers:58] Start watching changes [I 150708 17:57:26 handlers:60] Start detecting changes Click on the link to view the result in your browser. As you continue to edit the server should notice the change, regenerate and trigger your browser to refresh.","title":"To preview"},{"location":"meta/meta/#to-deploy","text":"$ mkdocs gh-deploy --clean After a brief moment this will update the main docs site .","title":"To deploy"},{"location":"test/","text":"Table of Contents 1. Prerequisites 1.1. Automated installation 1.2. Manual installation 2. Building 2.1. Preparing the source 2.2. Building 3. Developing 3.1. Build Dancing 3.2. Debug 3.3. New packages 3.3.1. Considerations 3.3.2. Source Package Conventions. 3.3.3. Build packages 3.3.4. Namespaces 3.3.5. Tests 3.4. Dealing with git submodules Prerequisites Some external packages are required as described in this section. Automated installation It is recommended to use the automated installation method to install the required externals. Follow the directions in wire-cell-externals and come back here after setting up your user environment. Manual installation You may provide the external packages yourself. The definitive list of required packages, their versions and build details are kept in wire-cell-externals worch.cfg file. Refer to that for the most up-to-date information on what software is needed. In summary you will need: ROOT v6 Python 2.7 BOOST 1.55 (or equiv) You will need to set up your run-time environment so that these commands do not fail and give the expected version: $ root -b -q ... | Welcome to ROOT 6.02/05 http://root.cern.ch | ... $ python -c 'import ROOT; print ROOT.gROOT.GetVersion()' 6.02/05 Building Preparing the source The wire cell source project uses git-submodules to bring all the source together: $ git clone git@github.com:BNLIF/wire-cell.git $ cd wire-cell $ git submodule init $ git submodule update $ alias waf=`pwd`/waf-tools/waf Building To configure, build and install the wire cell code do: $ waf --prefix=/path/to/install configure build install Note: this is not a Worch build - there is no --orch-config option. If you followed the single rooted install pattern then the /path/to/install can be /path/to/single-rooted and no additional user environment will be needed for run-time and the following command line should succeed: $ python -c 'import ROOT; print ROOT.WireCellData' Warning in <TInterpreter::ReadRootmapFile>: class pair<float,float> found in libCore.so is already in libWireCellDataDict.so Warning in <TInterpreter::ReadRootmapFile>: class pair<int,float> found in libCore.so is already in libWireCellDataDict.so <class 'ROOT.WireCellData'> If you provided your own externals or used the name/version tree pattern (using environment modules) then you will need to set your environment properly. Besides the usual $PATH , $LD_LIBRARY_PATH , etc pointing at /path/to/install you may need to set PYTHONPATH . Independent from how you installed the code, if you have the broken ROOT packages for Ubuntu installed you will have to set: $ export PYTHONNOUSERSITE=yes Developing Here is what you will do in the act of developing code. Build Dancing To rebuild after hacking on the source just type: $ waf When ready to install into the configured \"prefix\" installation area: $ waf install To force a full rebuild: $ waf clean build To limit building to just one submodule: $ cd <subdir>/ $ waf Debug To build for debugging one needs to reconfigure waf with a --build-debug=<flags> option and then the project must be cleaned and rebuilt. This can be done all at once like: $ waf --prefix=/path/to/install --build-debug=-ggdb3 clean configure build install You may also want to see what commands Waf is actually running to confirm this option is transmitted, just add a \" -v \" to the command line: $ waf -v Finally, run GDB in your usual, preferred manner: $ gdb --args /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource (gdb) run New packages New wire-cell packages can be added easily. Considerations Wire Cell packages are organized to be easy to create. It's much better to create many small packages and maybe later merge them than it is to split apart ones which have grown too monolithic. When thinking about writing some code consider: What other packages will I need? What future packages will need mine? You may have an idea for a package but in reality it is better split up into others. Here are reasons to believe your ideas fit into multiple packages: When I describe my expected package functionality I use the word \"and\". Some other package should use part of my package but the other part is not needed. If in doubt, make more, smaller packages. Source Package Conventions. To make them easy to build and aggregate they must follow a layout convention. First, each source package should be kept in it's own git repository. The recommended package naming convention is: wire-cell-NAME where \" NAME \" is some short identifier of the package's primary purpose. The contents of the source package must be organized following these sub-directory conventions: src/ : C++ source file for libraries with .cxx extensions or private headers inc/NAME/ : public/API C++ header files with .h extensions dict/LinkDef.h : ROOT linkdef header (for rootcling dictionaries) tests/ : Unit tests Python (nosetests) files like test_*.py or main C++ programs named like test_*.cxx . apps/ : main application(s), one appname.cxx file for each app named appname (todo: not yet supported) python/NAME : python modules (todo: not yet supported) wscript_build : a brief waf file The wscript_build file specifies a name for the binary package (in general similar but not identical to the source package name) and a list of any other packages part of the wire-cell system on which it depends. For example the wire-cell-nav source package builds to a WireCellNav binary package and it depends on the WireCellData package and so its wscript_build file is: bld.make_package('WireCellNav', use='WireCellData') This is Python and the bld object is a Waf build context. It is provided automagically when waf interprets this file. Build packages The above is about code packages. Code packages are built via a build package. This build package, wire-cell is but one possible \"view\" into all the wire cell packages. Other build packages may be created which only build some sub-set of all wire cell packages. To add a new code package to a build package (such as this one) one must do a little, annoying dance: $ mkdir <name> $ cd <name>/ $ echo \"bld.make_package('WireCell<Name>', use='WireCellNav WireCellData')\" > wscript_build $ git init $ git commit -a -m \"Start code package <name>\" Replace \" <name> \" with your package name. And, of course, you may want to put more code than just the wscript_build file. Also, that file should list what packages your package depends on. Now, make a new repository by going to the BNLIF GitHub and clicking \"New repository\" button. Give it a name like wire-cell-<name> . Copy-and-paste the two command it tells you to use: $ git remote add origin git@github.com:BNLIF/wire-cell-<name>.git $ git push -u origin master Finally, move aside the local repository and add it right back as a submodule: $ cd .. # back to top $ mv <name> <name>.moved $ git submodule add -- git@github.com:BNLIF/wire-cell-<name>.git <name> $ git submodule update $ git commit -a -m \"Added <name> to top-level build package.\" $ git push Whew! Namespaces The namespace WireCell is used for all \"core\" wire cell code. Code that is used to glue this core functionality into other systems may use another namespace but should not use WireCell . For example, the \"simple simulation tree\" uses =WireCellSst\". It can be tedious to type explicit namespace qualifiers all the time. You can use the using namespace WireCell; directive where in implementation files ( *.cxx ) but you should never use it in (top-scope) of header files as it will then leak the contents of the namespace into any unsuspecting file that #include 's it. Tests Tests go under the test/ (or tests/ ) sub-directory of the package. There are two types, C++ and Python. In both cases, only files that begin with \" test_* \" will be considered tests. Tests are automatically run as part of the build procedure (fixme: just C++ ones are automatic right now) and will be rerun when they or code they depend on changes. When tests are run by the build the stdout/stderr is typically captured. You can run them manually to observe any print statements. Tests are not installed but left in the \" build/ \" (or sometimes \" tmp/ \") output directory. Here are a few general guidelines for writing tests: write many tests write tests as fine grained as convenient the best tests are written before or while the code they test is being written test code does need not be \"pretty\", it will never be called from anywhere else tests should run quickly do use contrived data or mocked code to provide a bit of test code it's needed input or code support C++ tests Writing a C++ test is to write a main() program which takes no arguments . If a test fails, either let it crash the test program or call exit(1) . You can explicitly run C++ test programs. When they are run as part of the build, their full path is printed. When run automatically, waf takes care of setting up their environment so that their libraries are found. When run manually you will have to assure this. The simplest way is to \" waf install \" the package first. $ waf ... execution summary tests that pass 3/4 /home/bviren/projects/wire-cell/top/build/data/test_construct /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource /home/bviren/projects/wire-cell/top/build/sst/test_sst_geomdatasource tests that fail 1/4 /home/bviren/projects/wire-cell/top/build/data/test_fail 'build' finished successfully (1.594s) $ waf install $ /home/bviren/projects/wire-cell/top/build/sst/test_sst_geomdatasource Wire: 0 plane=1 index=0 Wire: 0 plane=1 index=1 Wire: 0 plane=1 index=2 ... Dealing with git submodules From the git book , do you updates like: $ git submodule update --remote --rebase or like $ git submodule update --remote --merge With: --rebase : put our local commits on top of any new ones --merge : merge our commits into new ones The first leaves a more \"linear\" commit history while the second leaves \"diamonds\" in the history whenever we have briefly diverged from the remote repository. You can run \" gitk --all \" in wire-cell or one of the submodules to see what I mean. Either way is fine. Rebasing looks cleaner in the history but merge captures the subtle fact of where our line of development actually diverged. In that link there are other interesting things to do: Configure your repository so \" git status \" in the top-level \"wire-cell\" gives us more info on the status of all submodules: $ git config status.submodulesummary 1 Make it so \" git diff \" in wire-cell will also show any diff's in the submodules: $ git config diff.submodule log To check that we will push in the right order (submodules first): $ git push --recurse-submodules=check To force submodules to push first $ git push --recurse-submodules=on-demand To run any command in all submodules $ git submodule foreach 'the command'","title":"Index"},{"location":"test/#prerequisites","text":"Some external packages are required as described in this section.","title":"Prerequisites"},{"location":"test/#automated-installation","text":"It is recommended to use the automated installation method to install the required externals. Follow the directions in wire-cell-externals and come back here after setting up your user environment.","title":"Automated installation"},{"location":"test/#manual-installation","text":"You may provide the external packages yourself. The definitive list of required packages, their versions and build details are kept in wire-cell-externals worch.cfg file. Refer to that for the most up-to-date information on what software is needed. In summary you will need: ROOT v6 Python 2.7 BOOST 1.55 (or equiv) You will need to set up your run-time environment so that these commands do not fail and give the expected version: $ root -b -q ... | Welcome to ROOT 6.02/05 http://root.cern.ch | ... $ python -c 'import ROOT; print ROOT.gROOT.GetVersion()' 6.02/05","title":"Manual installation"},{"location":"test/#building","text":"","title":"Building"},{"location":"test/#preparing-the-source","text":"The wire cell source project uses git-submodules to bring all the source together: $ git clone git@github.com:BNLIF/wire-cell.git $ cd wire-cell $ git submodule init $ git submodule update $ alias waf=`pwd`/waf-tools/waf","title":"Preparing the source"},{"location":"test/#building_1","text":"To configure, build and install the wire cell code do: $ waf --prefix=/path/to/install configure build install Note: this is not a Worch build - there is no --orch-config option. If you followed the single rooted install pattern then the /path/to/install can be /path/to/single-rooted and no additional user environment will be needed for run-time and the following command line should succeed: $ python -c 'import ROOT; print ROOT.WireCellData' Warning in <TInterpreter::ReadRootmapFile>: class pair<float,float> found in libCore.so is already in libWireCellDataDict.so Warning in <TInterpreter::ReadRootmapFile>: class pair<int,float> found in libCore.so is already in libWireCellDataDict.so <class 'ROOT.WireCellData'> If you provided your own externals or used the name/version tree pattern (using environment modules) then you will need to set your environment properly. Besides the usual $PATH , $LD_LIBRARY_PATH , etc pointing at /path/to/install you may need to set PYTHONPATH . Independent from how you installed the code, if you have the broken ROOT packages for Ubuntu installed you will have to set: $ export PYTHONNOUSERSITE=yes","title":"Building"},{"location":"test/#developing","text":"Here is what you will do in the act of developing code.","title":"Developing"},{"location":"test/#build-dancing","text":"To rebuild after hacking on the source just type: $ waf When ready to install into the configured \"prefix\" installation area: $ waf install To force a full rebuild: $ waf clean build To limit building to just one submodule: $ cd <subdir>/ $ waf","title":"Build Dancing"},{"location":"test/#debug","text":"To build for debugging one needs to reconfigure waf with a --build-debug=<flags> option and then the project must be cleaned and rebuilt. This can be done all at once like: $ waf --prefix=/path/to/install --build-debug=-ggdb3 clean configure build install You may also want to see what commands Waf is actually running to confirm this option is transmitted, just add a \" -v \" to the command line: $ waf -v Finally, run GDB in your usual, preferred manner: $ gdb --args /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource (gdb) run","title":"Debug"},{"location":"test/#new-packages","text":"New wire-cell packages can be added easily.","title":"New packages"},{"location":"test/#considerations","text":"Wire Cell packages are organized to be easy to create. It's much better to create many small packages and maybe later merge them than it is to split apart ones which have grown too monolithic. When thinking about writing some code consider: What other packages will I need? What future packages will need mine? You may have an idea for a package but in reality it is better split up into others. Here are reasons to believe your ideas fit into multiple packages: When I describe my expected package functionality I use the word \"and\". Some other package should use part of my package but the other part is not needed. If in doubt, make more, smaller packages.","title":"Considerations"},{"location":"test/#source-package-conventions","text":"To make them easy to build and aggregate they must follow a layout convention. First, each source package should be kept in it's own git repository. The recommended package naming convention is: wire-cell-NAME where \" NAME \" is some short identifier of the package's primary purpose. The contents of the source package must be organized following these sub-directory conventions: src/ : C++ source file for libraries with .cxx extensions or private headers inc/NAME/ : public/API C++ header files with .h extensions dict/LinkDef.h : ROOT linkdef header (for rootcling dictionaries) tests/ : Unit tests Python (nosetests) files like test_*.py or main C++ programs named like test_*.cxx . apps/ : main application(s), one appname.cxx file for each app named appname (todo: not yet supported) python/NAME : python modules (todo: not yet supported) wscript_build : a brief waf file The wscript_build file specifies a name for the binary package (in general similar but not identical to the source package name) and a list of any other packages part of the wire-cell system on which it depends. For example the wire-cell-nav source package builds to a WireCellNav binary package and it depends on the WireCellData package and so its wscript_build file is: bld.make_package('WireCellNav', use='WireCellData') This is Python and the bld object is a Waf build context. It is provided automagically when waf interprets this file.","title":"Source Package Conventions."},{"location":"test/#build-packages","text":"The above is about code packages. Code packages are built via a build package. This build package, wire-cell is but one possible \"view\" into all the wire cell packages. Other build packages may be created which only build some sub-set of all wire cell packages. To add a new code package to a build package (such as this one) one must do a little, annoying dance: $ mkdir <name> $ cd <name>/ $ echo \"bld.make_package('WireCell<Name>', use='WireCellNav WireCellData')\" > wscript_build $ git init $ git commit -a -m \"Start code package <name>\" Replace \" <name> \" with your package name. And, of course, you may want to put more code than just the wscript_build file. Also, that file should list what packages your package depends on. Now, make a new repository by going to the BNLIF GitHub and clicking \"New repository\" button. Give it a name like wire-cell-<name> . Copy-and-paste the two command it tells you to use: $ git remote add origin git@github.com:BNLIF/wire-cell-<name>.git $ git push -u origin master Finally, move aside the local repository and add it right back as a submodule: $ cd .. # back to top $ mv <name> <name>.moved $ git submodule add -- git@github.com:BNLIF/wire-cell-<name>.git <name> $ git submodule update $ git commit -a -m \"Added <name> to top-level build package.\" $ git push Whew!","title":"Build packages"},{"location":"test/#namespaces","text":"The namespace WireCell is used for all \"core\" wire cell code. Code that is used to glue this core functionality into other systems may use another namespace but should not use WireCell . For example, the \"simple simulation tree\" uses =WireCellSst\". It can be tedious to type explicit namespace qualifiers all the time. You can use the using namespace WireCell; directive where in implementation files ( *.cxx ) but you should never use it in (top-scope) of header files as it will then leak the contents of the namespace into any unsuspecting file that #include 's it.","title":"Namespaces"},{"location":"test/#tests","text":"Tests go under the test/ (or tests/ ) sub-directory of the package. There are two types, C++ and Python. In both cases, only files that begin with \" test_* \" will be considered tests. Tests are automatically run as part of the build procedure (fixme: just C++ ones are automatic right now) and will be rerun when they or code they depend on changes. When tests are run by the build the stdout/stderr is typically captured. You can run them manually to observe any print statements. Tests are not installed but left in the \" build/ \" (or sometimes \" tmp/ \") output directory. Here are a few general guidelines for writing tests: write many tests write tests as fine grained as convenient the best tests are written before or while the code they test is being written test code does need not be \"pretty\", it will never be called from anywhere else tests should run quickly do use contrived data or mocked code to provide a bit of test code it's needed input or code support C++ tests Writing a C++ test is to write a main() program which takes no arguments . If a test fails, either let it crash the test program or call exit(1) . You can explicitly run C++ test programs. When they are run as part of the build, their full path is printed. When run automatically, waf takes care of setting up their environment so that their libraries are found. When run manually you will have to assure this. The simplest way is to \" waf install \" the package first. $ waf ... execution summary tests that pass 3/4 /home/bviren/projects/wire-cell/top/build/data/test_construct /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource /home/bviren/projects/wire-cell/top/build/sst/test_sst_geomdatasource tests that fail 1/4 /home/bviren/projects/wire-cell/top/build/data/test_fail 'build' finished successfully (1.594s) $ waf install $ /home/bviren/projects/wire-cell/top/build/sst/test_sst_geomdatasource Wire: 0 plane=1 index=0 Wire: 0 plane=1 index=1 Wire: 0 plane=1 index=2 ...","title":"Tests"},{"location":"test/#dealing-with-git-submodules","text":"From the git book , do you updates like: $ git submodule update --remote --rebase or like $ git submodule update --remote --merge With: --rebase : put our local commits on top of any new ones --merge : merge our commits into new ones The first leaves a more \"linear\" commit history while the second leaves \"diamonds\" in the history whenever we have briefly diverged from the remote repository. You can run \" gitk --all \" in wire-cell or one of the submodules to see what I mean. Either way is fine. Rebasing looks cleaner in the history but merge captures the subtle fact of where our line of development actually diverged. In that link there are other interesting things to do: Configure your repository so \" git status \" in the top-level \"wire-cell\" gives us more info on the status of all submodules: $ git config status.submodulesummary 1 Make it so \" git diff \" in wire-cell will also show any diff's in the submodules: $ git config diff.submodule log To check that we will push in the right order (submodules first): $ git push --recurse-submodules=check To force submodules to push first $ git push --recurse-submodules=on-demand To run any command in all submodules $ git submodule foreach 'the command'","title":"Dealing with git submodules"},{"location":"viz/bee/","text":"Introduction to Bee Requirements Basic Interactions Advanced Interactions Show and Overlay results from different algorithms Hotkeys Introduction to Bee Displaying 3D reconstruction results is difficult. Often it requires installation of some platform-dependent programs and downloading some pre-formated data. For most physicists, it's too much effort (\"Just show me the results!\") Bee is a web-based application intended to solve this problem, and brings the interactive 3D world to the physicists. Some of the features include: No installation : Just go to the Bee homepage . Cross-platform : Runs everywhere with a modern web browser that supports WebGL , including mobile devices. Easy share : Each event has its own url that can be shared with anyone in the world. Interactive : Unleashes the power of WebGL with mouse and keyboard. Cross experiments : Supports most LArTPC detector geometries. Ready for analysis : User uploads, multiple algorithms, MC truth, customizable overlay, etc. Requirements The only requirements to run Bee are: A modern web browser that supports WebGL. ( Will my browser work? ) We recommend Google Chrome for the best experience. An internet connection. A relatively good graphic card. A discrete GPU greatly enhances the performance. Basic Interactions The following table summarizes the basic interactions with Bee on different devices: Action Mouse Keyboard Touch Rotate Left button drag One-finger touch Pan Right button drag Left / Right / Up / Down Three-finger swipe Zoom in / Zoom out Mouse wheel Shift+Up / Shift+Down Pinch & Zoom Advanced Interactions Show and Overlay results from different algorithms Bee supports any algorithms that produce a set of 3D space points (with or without charge). In the right control panel, the \"Recon\" folder shows the list of algorithms that Bee can load. By default, only the first one is loaded and its space points are displayed on screen. To show others: Click on the name of the algorithm. If it is not loaded yet, Bee will download its space points from the server. Notice that the left panel now shows the name, size, opacity and color of the current actively selected algorithm. Increase the opacity until it is displayed on screen. You can now switch to other algorithms to adjust their opacity so that they can be overlayed. You may need to uncheck the \"Show Charge\" checkbox (on the right panel) so that the algorithm can be represented by a single color. Hotkeys Users may find it convenient that most actions in BEE can be achieved using keyboard shortcuts. The full list of hot-keys can be found through \"Menu -> View -> Hotkey List\", and is also summarized below: Command Hotkey Command Hotkey Toggle MC m Toggle Charge q Next Event Shift+n Prev Event Shift+p Next Recon ] Prev Recon [ Next Slice k Prev Slice j Next Flash > Prev Flash < Center to Event c Reset Camera r X-U view u X-V view v X-Z view z X-Y view x Zoom in Shift+Up Zoom out Shift+Down Select Recon 1 - 9 Unselect All Esc Increase Opacity = Decrease Opacity - Increase Point Size + Decrease Point Size _ Redraw All Points o Show FPS s","title":"Bee"},{"location":"viz/bee/#introduction-to-bee","text":"Displaying 3D reconstruction results is difficult. Often it requires installation of some platform-dependent programs and downloading some pre-formated data. For most physicists, it's too much effort (\"Just show me the results!\") Bee is a web-based application intended to solve this problem, and brings the interactive 3D world to the physicists. Some of the features include: No installation : Just go to the Bee homepage . Cross-platform : Runs everywhere with a modern web browser that supports WebGL , including mobile devices. Easy share : Each event has its own url that can be shared with anyone in the world. Interactive : Unleashes the power of WebGL with mouse and keyboard. Cross experiments : Supports most LArTPC detector geometries. Ready for analysis : User uploads, multiple algorithms, MC truth, customizable overlay, etc.","title":"Introduction to Bee"},{"location":"viz/bee/#requirements","text":"The only requirements to run Bee are: A modern web browser that supports WebGL. ( Will my browser work? ) We recommend Google Chrome for the best experience. An internet connection. A relatively good graphic card. A discrete GPU greatly enhances the performance.","title":"Requirements"},{"location":"viz/bee/#basic-interactions","text":"The following table summarizes the basic interactions with Bee on different devices: Action Mouse Keyboard Touch Rotate Left button drag One-finger touch Pan Right button drag Left / Right / Up / Down Three-finger swipe Zoom in / Zoom out Mouse wheel Shift+Up / Shift+Down Pinch & Zoom","title":"Basic Interactions"},{"location":"viz/bee/#advanced-interactions","text":"","title":"Advanced Interactions"},{"location":"viz/bee/#show-and-overlay-results-from-different-algorithms","text":"Bee supports any algorithms that produce a set of 3D space points (with or without charge). In the right control panel, the \"Recon\" folder shows the list of algorithms that Bee can load. By default, only the first one is loaded and its space points are displayed on screen. To show others: Click on the name of the algorithm. If it is not loaded yet, Bee will download its space points from the server. Notice that the left panel now shows the name, size, opacity and color of the current actively selected algorithm. Increase the opacity until it is displayed on screen. You can now switch to other algorithms to adjust their opacity so that they can be overlayed. You may need to uncheck the \"Show Charge\" checkbox (on the right panel) so that the algorithm can be represented by a single color.","title":"Show and Overlay results from different algorithms"},{"location":"viz/bee/#hotkeys","text":"Users may find it convenient that most actions in BEE can be achieved using keyboard shortcuts. The full list of hot-keys can be found through \"Menu -> View -> Hotkey List\", and is also summarized below: Command Hotkey Command Hotkey Toggle MC m Toggle Charge q Next Event Shift+n Prev Event Shift+p Next Recon ] Prev Recon [ Next Slice k Prev Slice j Next Flash > Prev Flash < Center to Event c Reset Camera r X-U view u X-V view v X-Z view z X-Y view x Zoom in Shift+Up Zoom out Shift+Down Select Recon 1 - 9 Unselect All Esc Increase Opacity = Decrease Opacity - Increase Point Size + Decrease Point Size _ Redraw All Points o Show FPS s","title":"Hotkeys"},{"location":"viz/uploads/","text":"JSON Schema Upload File Structure Tools Convert Wire-Cell Output to BEE Convert LArSoft Output to BEE JSON Schema BEE can be used to display results from any algorithms that produce 3D space points . At the core, it parses a JSON file that looks like: { \"runNo\" : \"10000007\", \"subRunNo\" : \"16\", \"eventNo\" : \"1501\", \"x\" : [1.0, 1.0, 3.0], \"y\" : [2.0, 3.0, 4.0], \"z\" : [3.0, 7.0, 4.5], \"q\" : [3000, 4200, 5600], \"geom\" : \"uboone\", \"type\" : \"wire-cell\" } In the JSON file, only the x , y , and z variables are required, all others are optional. Their descriptions are summarized below: Name Description Default x array of x coordinates of the 3D space points [cm] (required) y array of y coordinates of the 3D space points [cm] (required) z array of z coordinates of the 3D space points [cm] (required) q array of charges for the 3D space points [number of electrons] [0,..] runNo DAQ run number 0 subRunNo DAQ subrun number 0 eventNo DAQ event number 0 geom name of the detector geometry (\"uboone\", \"dune35t\", \"protodune\") \"uboone\" type name of the algorithm \"\" Upload File Structure BEE supports user uploads through drag-and-drop to the dropzone on the BEE homepage . The uploaded file must be a .zip file that contains the following structure myfile.zip \u2514\u2500\u2500 data \u251c\u2500\u2500 0 \u2502 \u251c\u2500\u2500 0-myAlg1.json \u2502 \u251c\u2500\u2500 0-myAlg2.json \u2502 \u251c\u2500\u2500 0-myAlg3.json \u251c\u2500\u2500 1 \u2502 \u251c\u2500\u2500 1-myAlg1.json \u2502 \u251c\u2500\u2500 1-myAlg1.json \u2502 \u251c\u2500\u2500 1-myAlg1.json or, more specifically: the top directory must be named data/ each event has its own numbered sub-directory each algorithm has its own JSON file the JSON file should be named as {eventID}-{algName}.json the event ID should be sequential and start from 0 Once the directory and files are ready, the .zip file can be created with any prefered zip compression tools. As an example, in linux, one can create the myfile.zip file for upload by running zip -r myfile data Tools Convert Wire-Cell Output to BEE Download the the two files from here , then run python dump_json.py [filename] [alg1 alg2 ...] The currently available Wire-Cell algorithms are simple , charge , true , and deblob . At the end of the run, a to_upload.zip is created and can be drag-to-upload to BEE Some notes: The default algorithms to run are simple and charge if not specified The script expects the ROOT file ending with _{eventID}.root , and will actually run through all files in the same directory that have the same prefix. If your files are in the same directory but have different prefix, you can use a special syntax python dump_json.py 'yourdir/*_*.root' [alg1 alg2 ...] . Please don't foget the single quotes. Convert LArSoft Output to BEE Assuming that you have larsoft installed, (if not, follow here ), simply run the following script to convert your larsoft output to BEE lar -c celltree_dune35t.fcl [filename] or, for MicroBooNE / protoDUNE, change the corresponding .fcl file to celltree_uboone.fcl / celltree_protodune.fcl . It will create a bee/bee_upload.zip file under your working directory. You can then drag-and-drop the zip file to BEE to view the results (and MC tracks). The CellTree module is located under larreco/WireCell/ It works for any larsoft output that contains Space Points . To change or add different SpacePoint algorithms (it supports multiple algorithms), copy the celltree_{detector}.fcl file to your working directory and modify the line SpacePointLabels: [\"pmtrackdc\"] to include your favorate algorithms.","title":"User Uploads"},{"location":"viz/uploads/#json-schema","text":"BEE can be used to display results from any algorithms that produce 3D space points . At the core, it parses a JSON file that looks like: { \"runNo\" : \"10000007\", \"subRunNo\" : \"16\", \"eventNo\" : \"1501\", \"x\" : [1.0, 1.0, 3.0], \"y\" : [2.0, 3.0, 4.0], \"z\" : [3.0, 7.0, 4.5], \"q\" : [3000, 4200, 5600], \"geom\" : \"uboone\", \"type\" : \"wire-cell\" } In the JSON file, only the x , y , and z variables are required, all others are optional. Their descriptions are summarized below: Name Description Default x array of x coordinates of the 3D space points [cm] (required) y array of y coordinates of the 3D space points [cm] (required) z array of z coordinates of the 3D space points [cm] (required) q array of charges for the 3D space points [number of electrons] [0,..] runNo DAQ run number 0 subRunNo DAQ subrun number 0 eventNo DAQ event number 0 geom name of the detector geometry (\"uboone\", \"dune35t\", \"protodune\") \"uboone\" type name of the algorithm \"\"","title":"JSON Schema"},{"location":"viz/uploads/#upload-file-structure","text":"BEE supports user uploads through drag-and-drop to the dropzone on the BEE homepage . The uploaded file must be a .zip file that contains the following structure myfile.zip \u2514\u2500\u2500 data \u251c\u2500\u2500 0 \u2502 \u251c\u2500\u2500 0-myAlg1.json \u2502 \u251c\u2500\u2500 0-myAlg2.json \u2502 \u251c\u2500\u2500 0-myAlg3.json \u251c\u2500\u2500 1 \u2502 \u251c\u2500\u2500 1-myAlg1.json \u2502 \u251c\u2500\u2500 1-myAlg1.json \u2502 \u251c\u2500\u2500 1-myAlg1.json or, more specifically: the top directory must be named data/ each event has its own numbered sub-directory each algorithm has its own JSON file the JSON file should be named as {eventID}-{algName}.json the event ID should be sequential and start from 0 Once the directory and files are ready, the .zip file can be created with any prefered zip compression tools. As an example, in linux, one can create the myfile.zip file for upload by running zip -r myfile data","title":"Upload File Structure"},{"location":"viz/uploads/#tools","text":"","title":"Tools"},{"location":"viz/uploads/#convert-wire-cell-output-to-bee","text":"Download the the two files from here , then run python dump_json.py [filename] [alg1 alg2 ...] The currently available Wire-Cell algorithms are simple , charge , true , and deblob . At the end of the run, a to_upload.zip is created and can be drag-to-upload to BEE Some notes: The default algorithms to run are simple and charge if not specified The script expects the ROOT file ending with _{eventID}.root , and will actually run through all files in the same directory that have the same prefix. If your files are in the same directory but have different prefix, you can use a special syntax python dump_json.py 'yourdir/*_*.root' [alg1 alg2 ...] . Please don't foget the single quotes.","title":"Convert Wire-Cell Output to BEE"},{"location":"viz/uploads/#convert-larsoft-output-to-bee","text":"Assuming that you have larsoft installed, (if not, follow here ), simply run the following script to convert your larsoft output to BEE lar -c celltree_dune35t.fcl [filename] or, for MicroBooNE / protoDUNE, change the corresponding .fcl file to celltree_uboone.fcl / celltree_protodune.fcl . It will create a bee/bee_upload.zip file under your working directory. You can then drag-and-drop the zip file to BEE to view the results (and MC tracks). The CellTree module is located under larreco/WireCell/ It works for any larsoft output that contains Space Points . To change or add different SpacePoint algorithms (it supports multiple algorithms), copy the celltree_{detector}.fcl file to your working directory and modify the line SpacePointLabels: [\"pmtrackdc\"] to include your favorate algorithms.","title":"Convert LArSoft Output to BEE"}]}