{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Wire Cell", 
            "title": "Overview"
        }, 
        {
            "location": "/#welcome-to-wire-cell", 
            "text": "", 
            "title": "Welcome to Wire Cell"
        }, 
        {
            "location": "/install/install/", 
            "text": "Prerequisites\n\n\nAutomated installation\n\n\nManual installation\n\n\n\n\n\n\nBuild\n\n\nPreparing the source\n\n\nBuilding\n\n\n\n\n\n\n\n\n\n\nPrerequisites\n\n\nSome external packages are required as described in this section.\n\n\nAutomated installation\n\n\nIt is recommended to use the automated installation method to install the required externals. Follow the directions in \nInstall Externals\n and come back here after setting up your user environment.\n\n\nManual installation\n\n\nYou may provide the external packages yourself. The definitive list of required packages, their versions and build details are kept in wire-cell-externals worch.cfg file. Refer to that for the most up-to-date information on what software is needed. In summary you will need:\n\n\n\n\nROOT v6\n\n\nPython 2.7\n\n\nBOOST 1.55 (or equiv)\n\n\n\n\nYou will need to set up your run-time environment so that these commands do not fail and give the expected version:\n\n\n$ root -b -q\n...\n| Welcome to ROOT 6.02/05                http://root.cern.ch |\n...\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.02/05\n\n\n\n\nBuild\n\n\nPreparing the source\n\n\nThe wire cell source project uses \ngit-submodules\n to bring all the source together:\n\n\n$ git clone git@github.com:BNLIF/wire-cell.git\n$ cd wire-cell\n$ git submodule init\n$ git submodule update\n\n$ alias waf=`pwd`/waf-tools/waf\n\n\n\n\nBuilding\n\n\nTo configure, build and install the wire cell code do:\n\n\n$ waf --prefix=/path/to/install configure build install\n\n\n\n\nNote: this is not a Worch build - there is no \n--orch-config\n option.\n\n\nIf you followed the \nsingle rooted install\n pattern then the \n/path/to/install\n can be \n/path/to/single-rooted\n and no additional user environment will be needed for run-time and the following command line should succeed:\n\n\n$ python -c 'import ROOT; print ROOT.WireCellData'\nWarning in \nTInterpreter::ReadRootmapFile\n: class  pair\nfloat,float\n found in libCore.so  is already in libWireCellDataDict.so\nWarning in \nTInterpreter::ReadRootmapFile\n: class  pair\nint,float\n found in libCore.so  is already in libWireCellDataDict.so\n\nclass 'ROOT.WireCellData'\n\n\n\n\n\nIf you provided your own externals or used the name/version tree pattern (using environment modules) then you will need to set your environment properly. Besides the usual \n$PATH\n, \n$LD_LIBRARY_PATH\n, etc pointing at \n/path/to/install\n you may need to set \nPYTHONPATH\n.\n\n\nIndependent from how you installed the code, if you have the broken ROOT packages for Ubuntu installed you will have to set:\n\n\n$ export PYTHONNOUSERSITE=yes", 
            "title": "Install Wire Cell"
        }, 
        {
            "location": "/install/install/#prerequisites", 
            "text": "Some external packages are required as described in this section.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/install/install/#automated-installation", 
            "text": "It is recommended to use the automated installation method to install the required externals. Follow the directions in  Install Externals  and come back here after setting up your user environment.", 
            "title": "Automated installation"
        }, 
        {
            "location": "/install/install/#manual-installation", 
            "text": "You may provide the external packages yourself. The definitive list of required packages, their versions and build details are kept in wire-cell-externals worch.cfg file. Refer to that for the most up-to-date information on what software is needed. In summary you will need:   ROOT v6  Python 2.7  BOOST 1.55 (or equiv)   You will need to set up your run-time environment so that these commands do not fail and give the expected version:  $ root -b -q\n...\n| Welcome to ROOT 6.02/05                http://root.cern.ch |\n...\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.02/05", 
            "title": "Manual installation"
        }, 
        {
            "location": "/install/install/#build", 
            "text": "", 
            "title": "Build"
        }, 
        {
            "location": "/install/install/#preparing-the-source", 
            "text": "The wire cell source project uses  git-submodules  to bring all the source together:  $ git clone git@github.com:BNLIF/wire-cell.git\n$ cd wire-cell\n$ git submodule init\n$ git submodule update\n\n$ alias waf=`pwd`/waf-tools/waf", 
            "title": "Preparing the source"
        }, 
        {
            "location": "/install/install/#building", 
            "text": "To configure, build and install the wire cell code do:  $ waf --prefix=/path/to/install configure build install  Note: this is not a Worch build - there is no  --orch-config  option.  If you followed the  single rooted install  pattern then the  /path/to/install  can be  /path/to/single-rooted  and no additional user environment will be needed for run-time and the following command line should succeed:  $ python -c 'import ROOT; print ROOT.WireCellData'\nWarning in  TInterpreter::ReadRootmapFile : class  pair float,float  found in libCore.so  is already in libWireCellDataDict.so\nWarning in  TInterpreter::ReadRootmapFile : class  pair int,float  found in libCore.so  is already in libWireCellDataDict.so class 'ROOT.WireCellData'   If you provided your own externals or used the name/version tree pattern (using environment modules) then you will need to set your environment properly. Besides the usual  $PATH ,  $LD_LIBRARY_PATH , etc pointing at  /path/to/install  you may need to set  PYTHONPATH .  Independent from how you installed the code, if you have the broken ROOT packages for Ubuntu installed you will have to set:  $ export PYTHONNOUSERSITE=yes", 
            "title": "Building"
        }, 
        {
            "location": "/install/external/", 
            "text": "Quickstart\n\n\nPreparation\n\n\nBuild\n\n\nInstall\n\n\nname/version tree\n\n\nsingle-rooted directory\n\n\nInstall to name/version tree\n\n\nSingle-rooted install\n\n\n\n\n\n\n\n\n\n\nThe \nwire-cell\n software in \nBNL IF GitHub\n depends on some software that may not come with your OS, in particular \nROOT\n.  This package provides a \nWorch\n configuration file to build that software.\n\n\nQuickstart\n\n\nIf you don\u2019t care what this does, just cut and paste:\n\n\n$ virtualenv /path/to/buildenv\n$ source /path/to/buildenv/bin/activate\n$ pip install worch\n\n$ git clone git@github.com:BNLIF/wire-cell-externals.git /path/to/work\n$ cd /path/to/work\n$ waf --prefix=/path/to/install --orch-config=worch.cfg configure build\n$ deactivate\n\n$ source /path/to/install/env.sh\n$ module load root\n\n\n\n\nYou would repeat those last two lines in any new shells. You can now test:\n\n\n$ root -b -q\n...\n| Welcome to ROOT 6.02/05                http://root.cern.ch |\n...\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.02/05\n\n\n\n\nMore details and build options are described in the following sections.\n\n\nPreparation\n\n\nIt is recommended to install the Worch build system into a Python virtual environment. This environment will be used only for building these externals.\n\n\n$ virtualenv /path/to/buildenv\n$ source /path/to/buildenv/bin/activate\n$ pip install worch\n\n\n\n\nThis wire-cell-externals repository provides the rest of what is needed. Clone it to some place with ample disk space (10s of GB).\n\n\n$ git clone git@github.com:BNLIF/wire-cell-externals.git /path/to/work\n$ cd /path/to/work\n\n\n\n\nBuild\n\n\nAfter the above is done, this one command builds all the external software:\n\n\n(1)  $ waf --prefix=/path/to/install --orch-config=worch.cfg configure\n(2)  $ waf\n(3)  $ deactivate\n\n\n\n\nThis does:\n\n\n\n\nConfigures the build according to the \nworch.cfg\n file and tells it where to install the final results\n\n\nPerforms the automated build of external packages. This takes ~1 hour on Intel i7 w/ an SSD.\n\n\nExit the virtualenv as it is no longer needed (\n/path/to/buildenv\n may be removed)\n\n\n\n\nInstall\n\n\nThere are two ways to install the results of the build which differ in the organization of the installation directory layout. They are:\n\n\nname/version tree\n\n\n\n\neach package is installed into \n/path/to/install/\nname\n/\nversion\n/{bin,lib,include}\n. This allows for multiple versions of each package to be installed in parallel supporting different versions of an overall collection. It allows purging of a particular version by simply deleting the directory, although with care not to break other packages which depend on it. The user environment must be modified (\nPATH\n, etc) to pick up all run-time aspects of each individual package.\n\n\n\n\nsingle-rooted directory\n\n\n\n\nall packages are installed in the same \n/path/to/install/{bin,lib,include}\n directory. User run-time environment still requires adjustment but only for a single aspect. Only one version of a package may be installed, and removing an installed package is not supported (but is possible).\nThis package supports both paradigms.\n\n\n\n\nThis package supports both paradigms.\n\n\nInstall to name/version tree\n\n\nBy default, and as part of the build procedure, one will produce a name/version tree installation area as designated by the \n--prefix\n option to \nwaf\n. The user run-time environment can be set up with the help of \nEnvironment Modules\n (EM) which are provided by the build.\n\n\n$ source /path/to/install/env.sh\n$ module load root\n\n$ root -b -q\n...\n| Welcome to ROOT 6.02/05                http://root.cern.ch |\n...\n\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.02/05\n\n\n\n\nSingle-rooted install\n\n\nIn addition to the population of /path/to/install as above, the build will produce a \u201ctarpack\u201d binary package file. These can simply be unpacked into a single-rooted directory.\n\n\n$ cd /path/to/work\n$ mkdir -p /path/to/single-rooted\n$ for n in tmp/tarpack/*.tgz; do tar -C /path/to/single-rooted -xf $n; done\n\n\n\n\nNo special environment setup mechanism is provided for this mechanism however one can largely piggy-back on the one ROOT provides:\n\n\n$ source /path/to/single-rooted/bin/thisroot.sh\n\n$ root -b -q\n...\n| Welcome to ROOT 6.02/05                http://root.cern.ch |\n...\n\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.02/05", 
            "title": "Install Externals"
        }, 
        {
            "location": "/install/external/#quickstart", 
            "text": "If you don\u2019t care what this does, just cut and paste:  $ virtualenv /path/to/buildenv\n$ source /path/to/buildenv/bin/activate\n$ pip install worch\n\n$ git clone git@github.com:BNLIF/wire-cell-externals.git /path/to/work\n$ cd /path/to/work\n$ waf --prefix=/path/to/install --orch-config=worch.cfg configure build\n$ deactivate\n\n$ source /path/to/install/env.sh\n$ module load root  You would repeat those last two lines in any new shells. You can now test:  $ root -b -q\n...\n| Welcome to ROOT 6.02/05                http://root.cern.ch |\n...\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.02/05  More details and build options are described in the following sections.", 
            "title": "Quickstart"
        }, 
        {
            "location": "/install/external/#preparation", 
            "text": "It is recommended to install the Worch build system into a Python virtual environment. This environment will be used only for building these externals.  $ virtualenv /path/to/buildenv\n$ source /path/to/buildenv/bin/activate\n$ pip install worch  This wire-cell-externals repository provides the rest of what is needed. Clone it to some place with ample disk space (10s of GB).  $ git clone git@github.com:BNLIF/wire-cell-externals.git /path/to/work\n$ cd /path/to/work", 
            "title": "Preparation"
        }, 
        {
            "location": "/install/external/#build", 
            "text": "After the above is done, this one command builds all the external software:  (1)  $ waf --prefix=/path/to/install --orch-config=worch.cfg configure\n(2)  $ waf\n(3)  $ deactivate  This does:   Configures the build according to the  worch.cfg  file and tells it where to install the final results  Performs the automated build of external packages. This takes ~1 hour on Intel i7 w/ an SSD.  Exit the virtualenv as it is no longer needed ( /path/to/buildenv  may be removed)", 
            "title": "Build"
        }, 
        {
            "location": "/install/external/#install", 
            "text": "There are two ways to install the results of the build which differ in the organization of the installation directory layout. They are:  name/version tree   each package is installed into  /path/to/install/ name / version /{bin,lib,include} . This allows for multiple versions of each package to be installed in parallel supporting different versions of an overall collection. It allows purging of a particular version by simply deleting the directory, although with care not to break other packages which depend on it. The user environment must be modified ( PATH , etc) to pick up all run-time aspects of each individual package.   single-rooted directory   all packages are installed in the same  /path/to/install/{bin,lib,include}  directory. User run-time environment still requires adjustment but only for a single aspect. Only one version of a package may be installed, and removing an installed package is not supported (but is possible).\nThis package supports both paradigms.   This package supports both paradigms.  Install to name/version tree  By default, and as part of the build procedure, one will produce a name/version tree installation area as designated by the  --prefix  option to  waf . The user run-time environment can be set up with the help of  Environment Modules  (EM) which are provided by the build.  $ source /path/to/install/env.sh\n$ module load root\n\n$ root -b -q\n...\n| Welcome to ROOT 6.02/05                http://root.cern.ch |\n...\n\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.02/05  Single-rooted install  In addition to the population of /path/to/install as above, the build will produce a \u201ctarpack\u201d binary package file. These can simply be unpacked into a single-rooted directory.  $ cd /path/to/work\n$ mkdir -p /path/to/single-rooted\n$ for n in tmp/tarpack/*.tgz; do tar -C /path/to/single-rooted -xf $n; done  No special environment setup mechanism is provided for this mechanism however one can largely piggy-back on the one ROOT provides:  $ source /path/to/single-rooted/bin/thisroot.sh\n\n$ root -b -q\n...\n| Welcome to ROOT 6.02/05                http://root.cern.ch |\n...\n\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.02/05", 
            "title": "Install"
        }, 
        {
            "location": "/dev/overview/", 
            "text": "An overview of the system with indications of current status and near\nterm plans is given as a diagram below.\n\n\n\n\n(figure as [\nPDF\n] or [\nDOT\n])\n\n\nThe legend for this diagram is:\n\n\n\n\n\n\ndotted line\n\n:   this step is missing and needed.\n\n\n\n\n\n\ndashed line\n\n:   this step exists but is not captured so that anyone can perform it.\n\n\n\n\n\n\nsolid line\n\n:   this step exists, documented to some extent and anyone can reproduce it (eg, it's in GitHub).\n\n\n\n\n\n\nyellow\n\n:   this process exists but is not generally known/available.\n\n\n\n\n\n\nred\n\n:   this process does not exist or is just conceptual and is needed soon.\n\n\n\n\n\n\nfolder shape\n\n:   some file or file types\n\n\n\n\n\n\ncomponent shape\n\n:   some software package\n\n\n\n\n\n\nrectangle shape\n\n:   a program\n\n\n\n\n\n\ntrapezoid shape\n\n:   visualization or end-user application", 
            "title": "Overview"
        }, 
        {
            "location": "/dev/dev/", 
            "text": "Build Dancing\n\n\nDebug\n\n\nNew packages\n\n\nConsiderations\n\n\nSource Package Conventions\n\n\nBuild packages\n\n\n\n\n\n\nNamespaces\n\n\nDealing with git submodules\n\n\n\n\n\n\nHere is what you will do in the act of developing code.\n\n\nBuild Dancing\n\n\nTo rebuild after hacking on the source just type:\n\n\n$ waf\n\n\n\n\nWhen ready to install into the configured \u201cprefix\u201d installation area:\n\n\n$ waf install\n\n\n\n\nTo force a full rebuild:\n\n\n$ waf clean build\n\n\n\n\nTo limit building to just one submodule:\n\n\n$ cd \nsubdir\n/\n$ waf\n\n\n\n\nDebug\n\n\nTo build for debugging one needs to reconfigure waf with a \n--build-debug=\nflags\n option and then the project must be cleaned and rebuilt. This can be done all at once like:\n\n\n$ waf --prefix=/path/to/install --build-debug=-ggdb3 clean configure build install\n\n\n\n\nYou may also want to see what commands Waf is actually running to confirm this option is transmitted, just add a \n-v\n to the command line:\n\n\n$ waf -v\n\n\n\n\nFinally, run GDB in your usual, preferred manner:\n\n\n$ gdb --args /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource\n(gdb) run\n\n\n\n\nNew packages\n\n\nNew wire-cell packages can be added easily.\n\n\nConsiderations\n\n\nWire Cell packages are organized to be easy to create. It's much better to create many small packages and maybe later merge them than it is to split apart ones which have grown too monolithic. When thinking about writing some code consider\n\n\n\n\nWhat other packages will I need?\n\n\nWhat future packages will need mine?\n\n\n\n\nYou may have an idea for a package but in reality it is better split up into others. Here are reasons to believe your ideas fit into multiple packages:\n\n\n\n\nWhen I describe my expected package functionality I use the word \"and\".\n\n\nSome other package should use part of my package but the other part is not needed.\n\n\n\n\nIf in doubt, make more, smaller packages.\n\n\nSource Package Conventions\n\n\nTo make them easy to build and aggregate they must follow a layout convention.\n\n\nFirst, each source package should be kept in it's own git repository. The recommended package naming convention is:\n\n\nwire-cell-NAME\n\n\n\n\nwhere \nNAME\n is some short identifier of the package's primary purpose.\n\n\nThe contents of the source package must be organized following these sub-directory conventions\n\n\nsrc/             # C++ source file for libraries with .cxx extensions or private headers\ninc/NAME/        # public/API C++ header files with .h extensions\ndict/LinkDef.h   # ROOT linkdef header (for rootcling dictionaries)\ntests/           # Unit tests Python (nosetests) files like test_*.py or main C++ programs named like test_*.cxx.\napps/            # main application(s), one appname.cxx file for each app named appname (todo: not yet supported)\npython/NAME      # python modules (todo: not yet supported)\nwscript_build    # a brief waf file\n\n\n\n\nThe \nwscript_build\n file specifies a name for the binary package (in general similar but not identical to the source package name) and a list of any other packages part of the wire-cell system on which it depends. For example the \nwire-cell-nav\n source package builds to a \nWireCellNav\n binary package and it depends on the WireCellData package and so its \nwscript_build\n file is:\n\n\nbld.make_package('WireCellNav', use='WireCellData')\n\n\n\n\nThis is Python and the \nbld\n object is a Waf build context. It is provided automagically when waf interprets this file.\n\n\nBuild packages\n\n\nThe above is about code packages. Code packages are built via a build package. This build package, \nwire-cell\n is but one possible \"view\" into all the wire cell packages. Other build packages may be created which only build some sub-set of all wire cell packages.\n\n\nTo add a new code package to a build package (such as this one) one must do a little, annoying dance:\n\n\n$ mkdir \nname\n\n$ cd \nname\n/\n$ echo \nbld.make_package('WireCell\nName\n', use='WireCellNav WireCellData')\n \n wscript_build\n$ git init\n$ git commit -a -m \nStart code package \nname\n\n\n\n\n\nReplace \nname\n with your package name. And, of course, you may want to put more code than just the \nwscript_build\n file. Also, that file should list what packages your package depends on.\n\n\nNow, make a new repository by going to the \nBNLIF GitHub\n and clicking \"New repository\" button. Give it a name like \nwire-cell-\nname\n. Copy-and-paste the two command it tells you to use:\n\n\n$ git remote add origin git@github.com:BNLIF/wire-cell-\nname\n.git\n$ git push -u origin master\n\n\n\n\nFinally, move aside the local repository and add it right back as a submodule:\n\n\n$ cd ..  # back to top\n$ mv \nname\n \nname\n.moved\n$ git submodule add -- git@github.com:BNLIF/wire-cell-\nname\n.git \nname\n\n$ git submodule update\n$ git commit -a -m \nAdded \nname\n to top-level build package.\n\n$ git push\n\n\n\n\nWhew!\n\n\nNamespaces\n\n\nThe namespace WireCell is used for all \"core\" wire cell code. Code that is used to glue this core functionality into other systems may use another namespace but should not use WireCell. For example, the \"simple simulation tree\" uses \nWireCellSst\n.\n\n\nIt can be tedious to type explicit namespace qualifiers all the time. You can use the using namespace WireCell; directive where in implementation files (*.cxx) but you should never use it in (top-scope) of header files as it will then leak the contents of the namespace into any unsuspecting file that #include\u2019s it.\n\n\nDealing with git submodules\n\n\nFrom \nthe git book\n, do you updates like:\n\n\n$ git submodule update --remote --rebase\n\n\n\nor like\n\n\n$ git submodule update --remote --merge\n\n\n\nWith:\n\n\n\n\n\n\n--rebase\n:\n put our local commits on top of any new ones\n\n\n\n\n\n\n--merge\n:\n merge our commits into new ones\n\n\n\n\n\n\nThe first leaves a more \"linear\" commit history while the second leaves\n\"diamonds\" in the history whenever we have briefly diverged from the\nremote repository.  You can run \"\ngitk --all\n\" in wire-cell or one of the\nsubmodules to see what I mean.  Either way is fine.  Rebasing looks\ncleaner in the history but merge captures the subtle fact of where our\nline of development actually diverged.\n\n\nIn that link there are other interesting things to do:\n\n\n\n\n\n\nConfigure your repository so \"\ngit status\n\" in the top-level \"wire-cell\" gives us more info on the status of all submodules:\n\n\n$ git config status.submodulesummary 1\n\n\n\n\n\n\nMake it so \"\ngit diff\n\" in wire-cell will also show any diff's in the submodules:\n\n\n$ git config diff.submodule log\n\n\n\n\n\n\nTo check that we will push in the right order (submodules first):\n\n\n$ git push --recurse-submodules=check\n\n\n\n\n\n\nTo force submodules to push first\n\n\n$ git push --recurse-submodules=on-demand\n\n\n\n\n\n\nTo run any command in all submodules\n\n\n$ git submodule foreach 'the command'", 
            "title": "Developing"
        }, 
        {
            "location": "/dev/dev/#build-dancing", 
            "text": "To rebuild after hacking on the source just type:  $ waf  When ready to install into the configured \u201cprefix\u201d installation area:  $ waf install  To force a full rebuild:  $ waf clean build  To limit building to just one submodule:  $ cd  subdir /\n$ waf", 
            "title": "Build Dancing"
        }, 
        {
            "location": "/dev/dev/#debug", 
            "text": "To build for debugging one needs to reconfigure waf with a  --build-debug= flags  option and then the project must be cleaned and rebuilt. This can be done all at once like:  $ waf --prefix=/path/to/install --build-debug=-ggdb3 clean configure build install  You may also want to see what commands Waf is actually running to confirm this option is transmitted, just add a  -v  to the command line:  $ waf -v  Finally, run GDB in your usual, preferred manner:  $ gdb --args /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource\n(gdb) run", 
            "title": "Debug"
        }, 
        {
            "location": "/dev/dev/#new-packages", 
            "text": "New wire-cell packages can be added easily.", 
            "title": "New packages"
        }, 
        {
            "location": "/dev/dev/#considerations", 
            "text": "Wire Cell packages are organized to be easy to create. It's much better to create many small packages and maybe later merge them than it is to split apart ones which have grown too monolithic. When thinking about writing some code consider   What other packages will I need?  What future packages will need mine?   You may have an idea for a package but in reality it is better split up into others. Here are reasons to believe your ideas fit into multiple packages:   When I describe my expected package functionality I use the word \"and\".  Some other package should use part of my package but the other part is not needed.   If in doubt, make more, smaller packages.", 
            "title": "Considerations"
        }, 
        {
            "location": "/dev/dev/#source-package-conventions", 
            "text": "To make them easy to build and aggregate they must follow a layout convention.  First, each source package should be kept in it's own git repository. The recommended package naming convention is:  wire-cell-NAME  where  NAME  is some short identifier of the package's primary purpose.  The contents of the source package must be organized following these sub-directory conventions  src/             # C++ source file for libraries with .cxx extensions or private headers\ninc/NAME/        # public/API C++ header files with .h extensions\ndict/LinkDef.h   # ROOT linkdef header (for rootcling dictionaries)\ntests/           # Unit tests Python (nosetests) files like test_*.py or main C++ programs named like test_*.cxx.\napps/            # main application(s), one appname.cxx file for each app named appname (todo: not yet supported)\npython/NAME      # python modules (todo: not yet supported)\nwscript_build    # a brief waf file  The  wscript_build  file specifies a name for the binary package (in general similar but not identical to the source package name) and a list of any other packages part of the wire-cell system on which it depends. For example the  wire-cell-nav  source package builds to a  WireCellNav  binary package and it depends on the WireCellData package and so its  wscript_build  file is:  bld.make_package('WireCellNav', use='WireCellData')  This is Python and the  bld  object is a Waf build context. It is provided automagically when waf interprets this file.", 
            "title": "Source Package Conventions"
        }, 
        {
            "location": "/dev/dev/#build-packages", 
            "text": "The above is about code packages. Code packages are built via a build package. This build package,  wire-cell  is but one possible \"view\" into all the wire cell packages. Other build packages may be created which only build some sub-set of all wire cell packages.  To add a new code package to a build package (such as this one) one must do a little, annoying dance:  $ mkdir  name \n$ cd  name /\n$ echo  bld.make_package('WireCell Name ', use='WireCellNav WireCellData')    wscript_build\n$ git init\n$ git commit -a -m  Start code package  name   Replace  name  with your package name. And, of course, you may want to put more code than just the  wscript_build  file. Also, that file should list what packages your package depends on.  Now, make a new repository by going to the  BNLIF GitHub  and clicking \"New repository\" button. Give it a name like  wire-cell- name . Copy-and-paste the two command it tells you to use:  $ git remote add origin git@github.com:BNLIF/wire-cell- name .git\n$ git push -u origin master  Finally, move aside the local repository and add it right back as a submodule:  $ cd ..  # back to top\n$ mv  name   name .moved\n$ git submodule add -- git@github.com:BNLIF/wire-cell- name .git  name \n$ git submodule update\n$ git commit -a -m  Added  name  to top-level build package. \n$ git push  Whew!", 
            "title": "Build packages"
        }, 
        {
            "location": "/dev/dev/#namespaces", 
            "text": "The namespace WireCell is used for all \"core\" wire cell code. Code that is used to glue this core functionality into other systems may use another namespace but should not use WireCell. For example, the \"simple simulation tree\" uses  WireCellSst .  It can be tedious to type explicit namespace qualifiers all the time. You can use the using namespace WireCell; directive where in implementation files (*.cxx) but you should never use it in (top-scope) of header files as it will then leak the contents of the namespace into any unsuspecting file that #include\u2019s it.", 
            "title": "Namespaces"
        }, 
        {
            "location": "/dev/dev/#dealing-with-git-submodules", 
            "text": "From  the git book , do you updates like:  $ git submodule update --remote --rebase  or like  $ git submodule update --remote --merge  With:    --rebase :  put our local commits on top of any new ones    --merge :  merge our commits into new ones    The first leaves a more \"linear\" commit history while the second leaves\n\"diamonds\" in the history whenever we have briefly diverged from the\nremote repository.  You can run \" gitk --all \" in wire-cell or one of the\nsubmodules to see what I mean.  Either way is fine.  Rebasing looks\ncleaner in the history but merge captures the subtle fact of where our\nline of development actually diverged.  In that link there are other interesting things to do:    Configure your repository so \" git status \" in the top-level \"wire-cell\" gives us more info on the status of all submodules:  $ git config status.submodulesummary 1    Make it so \" git diff \" in wire-cell will also show any diff's in the submodules:  $ git config diff.submodule log    To check that we will push in the right order (submodules first):  $ git push --recurse-submodules=check    To force submodules to push first  $ git push --recurse-submodules=on-demand    To run any command in all submodules  $ git submodule foreach 'the command'", 
            "title": "Dealing with git submodules"
        }, 
        {
            "location": "/dev/test/", 
            "text": "Tests\n\n\nTests go under the \ntest/\n (or \ntests/\n) sub-directory of the package.  There are two types, C++ and Python.  In both cases, only files that begin with \"\ntest_*\n\" will be considered tests.  Tests are automatically run as part of the build procedure (fixme: just C++ ones are automatic right now) and will be rerun when they or code they depend on changes.   When tests are run by the build the \nstdout/stderr\n is typically captured.  You can run them manually to observe any print statements.  Tests are not installed but left in the \"\nbuild/\n\" (or sometimes \"\ntmp/\n\") output directory.\n\n\nHere are a few general guidelines for writing tests:\n\n\n\n\nwrite many tests\n\n\nwrite tests as fine grained as convenient\n\n\nthe best tests are written before or while the code they test is being written\n\n\ntest code does need not be \"pretty\", it will never be called from anywhere else\n\n\ntests should run quickly\n\n\ndo use contrived data or mocked code to provide a bit of test code it's needed input or code support\n\n\n\n\nC++ tests\n\n\nWriting a C++ test is to write a \nmain()\n program which takes \nno arguments\n.  If a test fails, either let it crash the test program or call \nexit(1)\n.\n\n\nYou can explicitly run C++ test programs.  When they are run as part of the build, their full path is printed.  When run automatically, waf takes care of setting up their environment so that their libraries are found.  When run manually you will have to assure this.  The simplest way is to \nwaf install\n\" the package first.\n\n\n$ waf\n...\nexecution summary\n  tests that pass 3/4\n    /home/bviren/projects/wire-cell/top/build/data/test_construct\n    /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource\n    /home/bviren/projects/wire-cell/top/build/sst/tgeomdatasource\n  tests that fail 1/4\n    /home/bviren/projects/wire-cell/top/build/data/test_fail\n'build' finished successfully\n\n$ waf install\n\n$ /home/bviren/projects/wire-cell/top/build/sst/test_sst_geomdatasource\nWire: 0 plane=1 index=0\nWire: 0 plane=1 index=1\nWire: 0 plane=1 index=2\n...", 
            "title": "Testing"
        }, 
        {
            "location": "/dev/test/#tests", 
            "text": "Tests go under the  test/  (or  tests/ ) sub-directory of the package.  There are two types, C++ and Python.  In both cases, only files that begin with \" test_* \" will be considered tests.  Tests are automatically run as part of the build procedure (fixme: just C++ ones are automatic right now) and will be rerun when they or code they depend on changes.   When tests are run by the build the  stdout/stderr  is typically captured.  You can run them manually to observe any print statements.  Tests are not installed but left in the \" build/ \" (or sometimes \" tmp/ \") output directory.  Here are a few general guidelines for writing tests:   write many tests  write tests as fine grained as convenient  the best tests are written before or while the code they test is being written  test code does need not be \"pretty\", it will never be called from anywhere else  tests should run quickly  do use contrived data or mocked code to provide a bit of test code it's needed input or code support", 
            "title": "Tests"
        }, 
        {
            "location": "/dev/test/#c-tests", 
            "text": "Writing a C++ test is to write a  main()  program which takes  no arguments .  If a test fails, either let it crash the test program or call  exit(1) .  You can explicitly run C++ test programs.  When they are run as part of the build, their full path is printed.  When run automatically, waf takes care of setting up their environment so that their libraries are found.  When run manually you will have to assure this.  The simplest way is to  waf install \" the package first.  $ waf\n...\nexecution summary\n  tests that pass 3/4\n    /home/bviren/projects/wire-cell/top/build/data/test_construct\n    /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource\n    /home/bviren/projects/wire-cell/top/build/sst/tgeomdatasource\n  tests that fail 1/4\n    /home/bviren/projects/wire-cell/top/build/data/test_fail\n'build' finished successfully\n\n$ waf install\n\n$ /home/bviren/projects/wire-cell/top/build/sst/test_sst_geomdatasource\nWire: 0 plane=1 index=0\nWire: 0 plane=1 index=1\nWire: 0 plane=1 index=2\n...", 
            "title": "C++ tests"
        }, 
        {
            "location": "/alg/cell/", 
            "text": "", 
            "title": "Making Cells"
        }, 
        {
            "location": "/alg/blob/", 
            "text": "", 
            "title": "Blob Reconstruction"
        }, 
        {
            "location": "/viz/webgl/", 
            "text": "", 
            "title": "WebGL"
        }
    ]
}