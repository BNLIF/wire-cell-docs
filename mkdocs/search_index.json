{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Wire Cell", 
            "title": "Overview"
        }, 
        {
            "location": "/#welcome-to-wire-cell", 
            "text": "", 
            "title": "Welcome to Wire Cell"
        }, 
        {
            "location": "/install/install/", 
            "text": "Installation of prerequisites\n\n\nPreparing wire-cell source\n\n\nBuilding wire-cell\n\n\nRun-time environment\n\n\n\n\n\n\nInstallation of prerequisites\n\n\nThe Wire Cell prototype code requires at least:\n\n\n\n\nBOOST 1.55 (or equiv)\n\n\nROOT v6\n\n\nPython 2.7 (optional unless you want Python bindings)\n\n\nwire-cell-xdata-root (follow \nthis instruction\n)\n\n\n\n\nMore information is available in the section \nInstall Externals\n. \nYou will need to set up your run-time environment so that these\ncommands do not fail and give the expected version:\n\n\n$ root -b -q\n...\n| Welcome to ROOT 6.05/01                    http://root.cern.ch |\n...\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.05/01\n\n\n\n\nPreparing wire-cell source\n\n\nWire Cell is made up of several source packages.  A top-level\n\nwire-cell\n package is used to aggregate them together as well as\nprovide the top-level build environment.  The aggregation is done\nusing Git submodules.\n\n\nIf you are a developer wanting to use SSH keys (default) to access the\nrepository clone with the appropriate URL:\n\n\n$ git clone git@github.com:BNLIF/wire-cell.git\n$ cd wire-cell/\n\n\n\n\nIf you are anonymous or in any case prefer to use HTTPS instead of SSH\nyou will need to clone as shown below and then convert the submodules\nto likewise use HTTPS via the provided script.\n\n\n$ git clone https://github.com/BNLIF/wire-cell.git\n$ cd wire-cell/\n$ ./switch-git-urls\n\n\n\n\nLater, you can switch back to developer/SSH URLs with:\n\n\n$ ./switch-git-urls dev\n\n\n\n\nNow get the submodules:\n\n\n$ git submodule init\n$ git submodule update\n\n\n\n\nFinally, it is convenient to set an alias to the copy of waf.\nOtherwise you'll need to specify it's full path or make it available\nin your \n$PATH\n.\n\n\n$ alias waf=`pwd`/waf-tools/waf\n\n\n\n\nBuilding wire-cell\n\n\nTo configure, build and install the wire cell code do:\n\n\n$ waf --prefix=/path/to/install configure build install\n\n\n\n\nIf the external prerequisites are not automatically found by \nwaf\n their locations can be set by some options. See \nwaf --help\n.\n\n\nRun-time environment\n\n\nSet up your run time environment following whatever method you chose\nto supply the external packages.\n\n\nFor wire-cell itself you will need to set or add to the usual:\n\n\n\n\nPATH\n\n\nLD_LIBRARY_PATH\n\n\nPYTHONPATH\n\n\n\n\nto point to directories under \n/path/to/install\n.\n\n\nSpecial notes:\n\n\n\n\nUbuntu:\n :: Set \nPYTHONNOUSERSITE\n to \nyes\n (or anything) if you also have Ubuntu ROOT packages installed.  This will stop the system PyROOT from being picked up\n\n\nScientific Linux:\n :: the build currently installs to both \nlib/\n and \nlib64/\n directories so add both to your \nLD_LIBRARY_PATH\n.\n\n\nInstall to single root:\n :: If you followed the \nsingle rooted install\n pattern \nand\n chose the \n/path/to/install\n to be coincident with \n/path/to/single-rooted\n then probably no additional user environment will be needed beyond sourcing ROOT's \nthisroot.sh\n.", 
            "title": "Install Wire Cell"
        }, 
        {
            "location": "/install/install/#installation-of-prerequisites", 
            "text": "The Wire Cell prototype code requires at least:   BOOST 1.55 (or equiv)  ROOT v6  Python 2.7 (optional unless you want Python bindings)  wire-cell-xdata-root (follow  this instruction )   More information is available in the section  Install Externals . \nYou will need to set up your run-time environment so that these\ncommands do not fail and give the expected version:  $ root -b -q\n...\n| Welcome to ROOT 6.05/01                    http://root.cern.ch |\n...\n$ python -c 'import ROOT; print ROOT.gROOT.GetVersion()'\n6.05/01", 
            "title": "Installation of prerequisites"
        }, 
        {
            "location": "/install/install/#preparing-wire-cell-source", 
            "text": "Wire Cell is made up of several source packages.  A top-level wire-cell  package is used to aggregate them together as well as\nprovide the top-level build environment.  The aggregation is done\nusing Git submodules.  If you are a developer wanting to use SSH keys (default) to access the\nrepository clone with the appropriate URL:  $ git clone git@github.com:BNLIF/wire-cell.git\n$ cd wire-cell/  If you are anonymous or in any case prefer to use HTTPS instead of SSH\nyou will need to clone as shown below and then convert the submodules\nto likewise use HTTPS via the provided script.  $ git clone https://github.com/BNLIF/wire-cell.git\n$ cd wire-cell/\n$ ./switch-git-urls  Later, you can switch back to developer/SSH URLs with:  $ ./switch-git-urls dev  Now get the submodules:  $ git submodule init\n$ git submodule update  Finally, it is convenient to set an alias to the copy of waf.\nOtherwise you'll need to specify it's full path or make it available\nin your  $PATH .  $ alias waf=`pwd`/waf-tools/waf", 
            "title": "Preparing wire-cell source"
        }, 
        {
            "location": "/install/install/#building-wire-cell", 
            "text": "To configure, build and install the wire cell code do:  $ waf --prefix=/path/to/install configure build install  If the external prerequisites are not automatically found by  waf  their locations can be set by some options. See  waf --help .", 
            "title": "Building wire-cell"
        }, 
        {
            "location": "/install/install/#run-time-environment", 
            "text": "Set up your run time environment following whatever method you chose\nto supply the external packages.  For wire-cell itself you will need to set or add to the usual:   PATH  LD_LIBRARY_PATH  PYTHONPATH   to point to directories under  /path/to/install .  Special notes:   Ubuntu:  :: Set  PYTHONNOUSERSITE  to  yes  (or anything) if you also have Ubuntu ROOT packages installed.  This will stop the system PyROOT from being picked up  Scientific Linux:  :: the build currently installs to both  lib/  and  lib64/  directories so add both to your  LD_LIBRARY_PATH .  Install to single root:  :: If you followed the  single rooted install  pattern  and  chose the  /path/to/install  to be coincident with  /path/to/single-rooted  then probably no additional user environment will be needed beyond sourcing ROOT's  thisroot.sh .", 
            "title": "Run-time environment"
        }, 
        {
            "location": "/install/external/", 
            "text": "Overview\n\n\nManual installation of externals\n\n\nCompiler\n\n\nROOT6\n\n\n\n\n\n\nAutomated installation with Spack\n\n\nSite installations\n\n\nRACF Setup\n\n\nFNAL Setup\n\n\n\n\n\n\nOS level installation\n\n\nMac\n\n\n\n\n\n\n\n\n\n\nOverview\n\n\nThe \nwire-cell\n software in \nBNL IF GitHub\n depends on some software that may not come with your OS, in particular \nROOT\n v6 and a possibly a compiler that supports C++11.\n\n\nThere are a few ways ways to supply the required externals described below.\n\n\n\n\n\n\nmanually build or otherwise provide them yourself.\n\n\n\n\n\n\nautomatically build and install them with \nSpack\n with support provided by the Wire Cell Toolkit's \nwire-cell-spack\n package.\n\n\n\n\n\n\nuse an existing site-installation.\n\n\n\n\n\n\nOS-level installation.\n\n\n\n\n\n\nThe following sections gives some guidance on each of these approaches.\n\n\nManual installation of externals\n\n\nYou may provide Wire Cell externals as you wish.  This section gives\nguidance on how to do this.\n\n\nSome general things to assure:\n\n\n\n\nuse the same compiler for all C++ packages.\n\n\nuse a compiler that supports C++11.\n\n\nall C++ packages built against the C++11 standard, eg GCC's \n-std=c++11\n flag.\n\n\n\n\nThe rest of this section gives some guidance on specific packages.\n\n\nCompiler\n\n\nYou must use a compiler that supports C++11.\nClang may work but is untested (please report successes/failures).\nGCC 4.9.2 is what the developers currently use.  \n\n\nNewer GCCs are more strict, particularly w.r.t. headers will likely uncover bugs of omission.  Please report them to the developers.\n\n\nROOT6\n\n\nCMake should used with at least these flags:\n\n\ncmake -Dminuit2=ON -Dpython=ON -Dcxx11=ON -DFFTW_LIBRARY=/path/to/lib/libfftw3.so [...]\n\n\n\n\nAutomated installation with Spack\n\n\nSpack\n is a \"meta build system\" that\nruns the individual build systems that come with packages.  It allows\none to manage an ever growing installation area which can accommodate\nmultiple versions of a package.  It also comes with support\nfor \nEnvironment Modules\n\n to handle your users' setup of these packages or can make targeted release \"views\" of its package tree.\n\n\nThe Wire Cell Toolkit provides a package \nwire-cell-spack\n\nwhich collects instructions and a Spack \"repo\" that builds WCT and its third-party dependencies.  This leverages Spacks built-in \"repo\" to provide dependencies needed by WCT's direct dependencies.  Using it will tend to build packages that one may already have installed through the OS (eg, Python).  However, this duplication should not add much to the overall build time which is automatic nor lead to any problems.\n\n\nAn installer that wishes to use wire-cell-spack to provide the dependencies should begin by following its \nREADME\n file.\n\n\nAlthough developed for the Wire Cell Toolkit, the resulting external dependencies will be suitable for the prototype.  However, some additional packages not strictly required may be built.\n\n\nSite installations\n\n\nSome sites associated with Wire Cell development have already been\nprovisioned with the necessary externals and you may leverage them.\n\n\nRACF Setup\n\n\nAt BNL's RACF, a simple, single-rooted installation of Wire Cell external packages is provided.\n\n\nBash users do:\n\n\n$ source /gpfs01/lbne/users/sw/wc/bin/thisroot.sh\n\n\n\n\nOr, if you are still stuck using \ntcsh\n do:\n\n\n source /gpfs01/lbne/users/sw/wc/bin/thisroot.csh\n\n\n\n\nFNAL Setup\n\n\nAt Fermilab, externals are provided by UPS.\n\n\n$ source /grid/fermiapp/products/larsoft/setups\n$ setup root v6_04_02 -q e7:prof\n$ setup boost v1_57_0 -q e7:prof\n\n\n\n\nOS level installation\n\n\nMac\n\n\nInstall homebrew and do\n\n\n$ brew install boost\n$ brew install homebrew/science/root6", 
            "title": "Install Externals"
        }, 
        {
            "location": "/install/external/#overview", 
            "text": "The  wire-cell  software in  BNL IF GitHub  depends on some software that may not come with your OS, in particular  ROOT  v6 and a possibly a compiler that supports C++11.  There are a few ways ways to supply the required externals described below.    manually build or otherwise provide them yourself.    automatically build and install them with  Spack  with support provided by the Wire Cell Toolkit's  wire-cell-spack  package.    use an existing site-installation.    OS-level installation.    The following sections gives some guidance on each of these approaches.", 
            "title": "Overview"
        }, 
        {
            "location": "/install/external/#manual-installation-of-externals", 
            "text": "You may provide Wire Cell externals as you wish.  This section gives\nguidance on how to do this.  Some general things to assure:   use the same compiler for all C++ packages.  use a compiler that supports C++11.  all C++ packages built against the C++11 standard, eg GCC's  -std=c++11  flag.   The rest of this section gives some guidance on specific packages.", 
            "title": "Manual installation of externals"
        }, 
        {
            "location": "/install/external/#compiler", 
            "text": "You must use a compiler that supports C++11.\nClang may work but is untested (please report successes/failures).\nGCC 4.9.2 is what the developers currently use.    Newer GCCs are more strict, particularly w.r.t. headers will likely uncover bugs of omission.  Please report them to the developers.", 
            "title": "Compiler"
        }, 
        {
            "location": "/install/external/#root6", 
            "text": "CMake should used with at least these flags:  cmake -Dminuit2=ON -Dpython=ON -Dcxx11=ON -DFFTW_LIBRARY=/path/to/lib/libfftw3.so [...]", 
            "title": "ROOT6"
        }, 
        {
            "location": "/install/external/#automated-installation-with-spack", 
            "text": "Spack  is a \"meta build system\" that\nruns the individual build systems that come with packages.  It allows\none to manage an ever growing installation area which can accommodate\nmultiple versions of a package.  It also comes with support\nfor  Environment Modules \n to handle your users' setup of these packages or can make targeted release \"views\" of its package tree.  The Wire Cell Toolkit provides a package  wire-cell-spack \nwhich collects instructions and a Spack \"repo\" that builds WCT and its third-party dependencies.  This leverages Spacks built-in \"repo\" to provide dependencies needed by WCT's direct dependencies.  Using it will tend to build packages that one may already have installed through the OS (eg, Python).  However, this duplication should not add much to the overall build time which is automatic nor lead to any problems.  An installer that wishes to use wire-cell-spack to provide the dependencies should begin by following its  README  file.  Although developed for the Wire Cell Toolkit, the resulting external dependencies will be suitable for the prototype.  However, some additional packages not strictly required may be built.", 
            "title": "Automated installation with Spack"
        }, 
        {
            "location": "/install/external/#site-installations", 
            "text": "Some sites associated with Wire Cell development have already been\nprovisioned with the necessary externals and you may leverage them.", 
            "title": "Site installations"
        }, 
        {
            "location": "/install/external/#racf-setup", 
            "text": "At BNL's RACF, a simple, single-rooted installation of Wire Cell external packages is provided.  Bash users do:  $ source /gpfs01/lbne/users/sw/wc/bin/thisroot.sh  Or, if you are still stuck using  tcsh  do:   source /gpfs01/lbne/users/sw/wc/bin/thisroot.csh", 
            "title": "RACF Setup"
        }, 
        {
            "location": "/install/external/#fnal-setup", 
            "text": "At Fermilab, externals are provided by UPS.  $ source /grid/fermiapp/products/larsoft/setups\n$ setup root v6_04_02 -q e7:prof\n$ setup boost v1_57_0 -q e7:prof", 
            "title": "FNAL Setup"
        }, 
        {
            "location": "/install/external/#os-level-installation", 
            "text": "", 
            "title": "OS level installation"
        }, 
        {
            "location": "/install/external/#mac", 
            "text": "Install homebrew and do  $ brew install boost\n$ brew install homebrew/science/root6", 
            "title": "Mac"
        }, 
        {
            "location": "/dev/overview/", 
            "text": "An overview of the system with indications of current status and near\nterm plans is given as a diagram below.\n\n\n\n\n([\nPNG\n], [\nPDF\n], [\nDOT\n] and for clickable links open [\nSVG\n])\n\n\nThe legend for this diagram is:\n\n\n\n\n\n\ndotted line\n\n:   this step is missing and needed.\n\n\n\n\n\n\ndashed line\n\n:   this step exists but is not captured so that anyone can perform it.\n\n\n\n\n\n\nsolid line\n\n:   this step exists, documented to some extent and anyone can reproduce it (eg, it's in GitHub).\n\n\n\n\n\n\nyellow\n\n:   this process exists but is not generally known/available.\n\n\n\n\n\n\nred\n\n:   this process does not exist or is just conceptual and is needed soon.\n\n\n\n\n\n\nfolder shape\n\n:   some file or file types\n\n\n\n\n\n\ncomponent shape\n\n:   some software package\n\n\n\n\n\n\nrectangle shape\n\n:   a program\n\n\n\n\n\n\ntrapezoid shape\n\n:   visualization or end-user application\n\n\n\n\n\n\nTerms\n\n\nThese terms are used with specific meanings in Wire Cell\n\n\n\n\n\n\ncoordinate system\n\n: electrons drift in the negative-X direction toward the wire planes, Y points upward and is sometimes referred to as W, Z follows from the right-hand-rule.  U and V directions point at some angle w.r.t. W and are in the W-Z plane.\n\n\n\n\n\n\ntick\n\n: the unit of digitized time.\n\n\n\n\n\n\ntbin\n\n: one bin of time of some integral number of ticks\n\n\n\n\n\n\nwire plane\n\n: a two-dimensional extent in the Y-Z plane which is perpendicular to the drift direction.  There is a U, V and W (aka Y) wire plane which contains \nwire\n segments.  Each of these planes are slightly offset in the drift direction X.\n\n\n\n\n\n\ncharge\n\n: refers to an amount of charged particles drifting past the wire plane during one tick.  Sometimes used to refer to the deconvolved ADC in one tick which provides a measure of the charge.  Sometimes used to refer to the un-deconvolved signal.  Yes, it's confusing. \n\n\n\n\n\n\nwire\n\n: a segment or run of the conductor which senses the passing of drifting charge.  A wire runs in either the U, V or W (aka Y) direction.\n\n\n\n\n\n\nchannel\n\n: the unit of electronics responsible for digitizing charge on a wire.  For detectors with wrapped readout conductors a single channel maps to multiple wires.\n\n\n\n\n\n\ncell\n\n: a region of the plane surrounding an area near where three wires, one from each plane, are crossing (at least pairwise, if not in a triple-point).\n\n\n\n\n\n\ntiling\n\n: the set of cells which fully cover the plane with no gaps nor overlaps.  There is more than one way to tile the plane.\n\n\n\n\n\n\nblob\n\n: an association of continguous cells which is expected to contain a portion of the charge of the event from one tbin.  In general, the association will include cells which may not actually contain charge.  A blob is bounded by cells (or plane boundaries) which definitely do not contain charge.\n\n\n\n\n\n\nblob cluster\n\n: an association of a number of blobs, potentially from different tbins, which intend to capture an extended portion of charge that came from the passage of a single particle (track) or multiple, closely related particles (shower).\n\n\n\n\n\n\nslice\n\n: a qualifier to indicate information from one tbin.  A wire slice would indicate the collection of charge collected on wires at a given time.\n\n\n\n\n\n\nframe\n\n: the collection of slices readout as a continuous unit from the DAQ.", 
            "title": "Overview"
        }, 
        {
            "location": "/dev/dev/", 
            "text": "Build Dancing\n\n\nDebug\n\n\nNew packages\n\n\nConsiderations\n\n\nSource Package Conventions\n\n\nBuild packages\n\n\n\n\n\n\nNamespaces\n\n\nDealing with git submodules\n\n\n\n\n\n\nHere is what you will do in the act of developing code.\n\n\nBuild Dancing\n\n\nTo rebuild after hacking on the source just type:\n\n\n$ waf\n\n\n\n\nWhen ready to install into the configured \u201cprefix\u201d installation area:\n\n\n$ waf install\n\n\n\n\nTo force a full rebuild:\n\n\n$ waf clean build\n\n\n\n\nTo limit building to just one submodule:\n\n\n$ cd \nsubdir\n/\n$ waf\n\n\n\n\nDebug\n\n\nTo build for debugging one needs to reconfigure waf with a \n--build-debug=\nflags\n option and then the project must be cleaned and rebuilt. This can be done all at once like:\n\n\n$ waf --prefix=/path/to/install --build-debug=-ggdb3 clean configure build install\n\n\n\n\nYou may also want to see what commands Waf is actually running to confirm this option is transmitted, just add a \n-v\n to the command line:\n\n\n$ waf -v\n\n\n\n\nFinally, run GDB in your usual, preferred manner:\n\n\n$ gdb --args /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource\n(gdb) run\n\n\n\n\nNew packages\n\n\nNew wire-cell packages can be added easily.\n\n\nConsiderations\n\n\nWire Cell packages are organized to be easy to create. It's much better to create many small packages and maybe later merge them than it is to split apart ones which have grown too monolithic. When thinking about writing some code consider\n\n\n\n\nWhat other packages will I need?\n\n\nWhat future packages will need mine?\n\n\n\n\nYou may have an idea for a package but in reality it is better split up into others. Here are reasons to believe your ideas fit into multiple packages:\n\n\n\n\nWhen I describe my expected package functionality I use the word \"and\".\n\n\nSome other package should use part of my package but the other part is not needed.\n\n\n\n\nIf in doubt, make more, smaller packages.\n\n\nSource Package Conventions\n\n\nTo make them easy to build and aggregate they must follow a layout convention.\n\n\nFirst, each source package should be kept in it's own git repository. The recommended package naming convention is:\n\n\nwire-cell-NAME\n\n\n\n\nwhere \nNAME\n is some short identifier of the package's primary purpose.\n\n\nThe contents of the source package must be organized following these sub-directory conventions\n\n\nsrc/             # C++ source file for libraries with .cxx extensions or private headers\ninc/NAME/        # public/API C++ header files with .h extensions\ndict/LinkDef.h   # ROOT linkdef header (for rootcling dictionaries)\ntests/           # Unit tests Python (nosetests) files like test_*.py or main C++ programs named like test_*.cxx.\napps/            # main application(s), one appname.cxx file for each app named appname (todo: not yet supported)\npython/NAME      # python modules (todo: not yet supported)\nwscript_build    # a brief waf file\n\n\n\n\nThe \nwscript_build\n file specifies a name for the binary package (in general similar but not identical to the source package name) and a list of any other packages part of the wire-cell system on which it depends. For example the \nwire-cell-nav\n source package builds to a \nWireCellNav\n binary package and it depends on the WireCellData package and so its \nwscript_build\n file is:\n\n\nbld.make_package('WireCellNav', use='WireCellData')\n\n\n\n\nThis is Python and the \nbld\n object is a Waf build context. It is provided automagically when waf interprets this file.\n\n\nBuild packages\n\n\nThe above is about code packages. Code packages are built via a build package. This build package, \nwire-cell\n is but one possible \"view\" into all the wire cell packages. Other build packages may be created which only build some sub-set of all wire cell packages.\n\n\nTo add a new code package to a build package (such as this one) one must do a little, annoying dance:\n\n\n$ mkdir \nname\n\n$ cd \nname\n/\n$ echo \nbld.make_package('WireCell\nName\n', use='WireCellNav WireCellData')\n \n wscript_build\n$ git init\n$ git commit -a -m \nStart code package \nname\n\n\n\n\n\nReplace \nname\n with your package name. And, of course, you may want to put more code than just the \nwscript_build\n file. Also, that file should list what packages your package depends on.\n\n\nNow, make a new repository by going to the \nBNLIF GitHub\n and clicking \"New repository\" button. Give it a name like \nwire-cell-\nname\n. Copy-and-paste the two command it tells you to use:\n\n\n$ git remote add origin git@github.com:BNLIF/wire-cell-\nname\n.git\n$ git push -u origin master\n\n\n\n\nFinally, move aside the local repository and add it right back as a submodule:\n\n\n$ cd ..  # back to top\n$ mv \nname\n \nname\n.moved\n$ git submodule add -- git@github.com:BNLIF/wire-cell-\nname\n.git \nname\n\n$ git submodule update\n$ git commit -a -m \nAdded \nname\n to top-level build package.\n\n$ git push\n\n\n\n\nWhew!\n\n\nNamespaces\n\n\nThe namespace WireCell is used for all \"core\" wire cell code. Code that is used to glue this core functionality into other systems may use another namespace but should not use WireCell. For example, the \"simple simulation tree\" uses \nWireCellSst\n.\n\n\nIt can be tedious to type explicit namespace qualifiers all the time. You can use the using namespace WireCell; directive where in implementation files (*.cxx) but you should never use it in (top-scope) of header files as it will then leak the contents of the namespace into any unsuspecting file that #include\u2019s it.\n\n\nDealing with git submodules\n\n\nFrom \nthe git book\n, do you updates like:\n\n\n$ git submodule update --remote --rebase\n\n\n\nor like\n\n\n$ git submodule update --remote --merge\n\n\n\nWith:\n\n\n\n\n\n\n--rebase\n:\n put our local commits on top of any new ones\n\n\n\n\n\n\n--merge\n:\n merge our commits into new ones\n\n\n\n\n\n\nThe first leaves a more \"linear\" commit history while the second leaves\n\"diamonds\" in the history whenever we have briefly diverged from the\nremote repository.  You can run \"\ngitk --all\n\" in wire-cell or one of the\nsubmodules to see what I mean.  Either way is fine.  Rebasing looks\ncleaner in the history but merge captures the subtle fact of where our\nline of development actually diverged.\n\n\nIn that link there are other interesting things to do:\n\n\n\n\n\n\nConfigure your repository so \"\ngit status\n\" in the top-level \"wire-cell\" gives us more info on the status of all submodules:\n\n\n$ git config status.submodulesummary 1\n\n\n\n\n\n\nMake it so \"\ngit diff\n\" in wire-cell will also show any diff's in the submodules:\n\n\n$ git config diff.submodule log\n\n\n\n\n\n\nTo check that we will push in the right order (submodules first):\n\n\n$ git push --recurse-submodules=check\n\n\n\n\n\n\nTo force submodules to push first\n\n\n$ git push --recurse-submodules=on-demand\n\n\n\n\n\n\nTo run any command in all submodules\n\n\n$ git submodule foreach 'the command'", 
            "title": "Building"
        }, 
        {
            "location": "/dev/dev/#build-dancing", 
            "text": "To rebuild after hacking on the source just type:  $ waf  When ready to install into the configured \u201cprefix\u201d installation area:  $ waf install  To force a full rebuild:  $ waf clean build  To limit building to just one submodule:  $ cd  subdir /\n$ waf", 
            "title": "Build Dancing"
        }, 
        {
            "location": "/dev/dev/#debug", 
            "text": "To build for debugging one needs to reconfigure waf with a  --build-debug= flags  option and then the project must be cleaned and rebuilt. This can be done all at once like:  $ waf --prefix=/path/to/install --build-debug=-ggdb3 clean configure build install  You may also want to see what commands Waf is actually running to confirm this option is transmitted, just add a  -v  to the command line:  $ waf -v  Finally, run GDB in your usual, preferred manner:  $ gdb --args /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource\n(gdb) run", 
            "title": "Debug"
        }, 
        {
            "location": "/dev/dev/#new-packages", 
            "text": "New wire-cell packages can be added easily.", 
            "title": "New packages"
        }, 
        {
            "location": "/dev/dev/#considerations", 
            "text": "Wire Cell packages are organized to be easy to create. It's much better to create many small packages and maybe later merge them than it is to split apart ones which have grown too monolithic. When thinking about writing some code consider   What other packages will I need?  What future packages will need mine?   You may have an idea for a package but in reality it is better split up into others. Here are reasons to believe your ideas fit into multiple packages:   When I describe my expected package functionality I use the word \"and\".  Some other package should use part of my package but the other part is not needed.   If in doubt, make more, smaller packages.", 
            "title": "Considerations"
        }, 
        {
            "location": "/dev/dev/#source-package-conventions", 
            "text": "To make them easy to build and aggregate they must follow a layout convention.  First, each source package should be kept in it's own git repository. The recommended package naming convention is:  wire-cell-NAME  where  NAME  is some short identifier of the package's primary purpose.  The contents of the source package must be organized following these sub-directory conventions  src/             # C++ source file for libraries with .cxx extensions or private headers\ninc/NAME/        # public/API C++ header files with .h extensions\ndict/LinkDef.h   # ROOT linkdef header (for rootcling dictionaries)\ntests/           # Unit tests Python (nosetests) files like test_*.py or main C++ programs named like test_*.cxx.\napps/            # main application(s), one appname.cxx file for each app named appname (todo: not yet supported)\npython/NAME      # python modules (todo: not yet supported)\nwscript_build    # a brief waf file  The  wscript_build  file specifies a name for the binary package (in general similar but not identical to the source package name) and a list of any other packages part of the wire-cell system on which it depends. For example the  wire-cell-nav  source package builds to a  WireCellNav  binary package and it depends on the WireCellData package and so its  wscript_build  file is:  bld.make_package('WireCellNav', use='WireCellData')  This is Python and the  bld  object is a Waf build context. It is provided automagically when waf interprets this file.", 
            "title": "Source Package Conventions"
        }, 
        {
            "location": "/dev/dev/#build-packages", 
            "text": "The above is about code packages. Code packages are built via a build package. This build package,  wire-cell  is but one possible \"view\" into all the wire cell packages. Other build packages may be created which only build some sub-set of all wire cell packages.  To add a new code package to a build package (such as this one) one must do a little, annoying dance:  $ mkdir  name \n$ cd  name /\n$ echo  bld.make_package('WireCell Name ', use='WireCellNav WireCellData')    wscript_build\n$ git init\n$ git commit -a -m  Start code package  name   Replace  name  with your package name. And, of course, you may want to put more code than just the  wscript_build  file. Also, that file should list what packages your package depends on.  Now, make a new repository by going to the  BNLIF GitHub  and clicking \"New repository\" button. Give it a name like  wire-cell- name . Copy-and-paste the two command it tells you to use:  $ git remote add origin git@github.com:BNLIF/wire-cell- name .git\n$ git push -u origin master  Finally, move aside the local repository and add it right back as a submodule:  $ cd ..  # back to top\n$ mv  name   name .moved\n$ git submodule add -- git@github.com:BNLIF/wire-cell- name .git  name \n$ git submodule update\n$ git commit -a -m  Added  name  to top-level build package. \n$ git push  Whew!", 
            "title": "Build packages"
        }, 
        {
            "location": "/dev/dev/#namespaces", 
            "text": "The namespace WireCell is used for all \"core\" wire cell code. Code that is used to glue this core functionality into other systems may use another namespace but should not use WireCell. For example, the \"simple simulation tree\" uses  WireCellSst .  It can be tedious to type explicit namespace qualifiers all the time. You can use the using namespace WireCell; directive where in implementation files (*.cxx) but you should never use it in (top-scope) of header files as it will then leak the contents of the namespace into any unsuspecting file that #include\u2019s it.", 
            "title": "Namespaces"
        }, 
        {
            "location": "/dev/dev/#dealing-with-git-submodules", 
            "text": "From  the git book , do you updates like:  $ git submodule update --remote --rebase  or like  $ git submodule update --remote --merge  With:    --rebase :  put our local commits on top of any new ones    --merge :  merge our commits into new ones    The first leaves a more \"linear\" commit history while the second leaves\n\"diamonds\" in the history whenever we have briefly diverged from the\nremote repository.  You can run \" gitk --all \" in wire-cell or one of the\nsubmodules to see what I mean.  Either way is fine.  Rebasing looks\ncleaner in the history but merge captures the subtle fact of where our\nline of development actually diverged.  In that link there are other interesting things to do:    Configure your repository so \" git status \" in the top-level \"wire-cell\" gives us more info on the status of all submodules:  $ git config status.submodulesummary 1    Make it so \" git diff \" in wire-cell will also show any diff's in the submodules:  $ git config diff.submodule log    To check that we will push in the right order (submodules first):  $ git push --recurse-submodules=check    To force submodules to push first  $ git push --recurse-submodules=on-demand    To run any command in all submodules  $ git submodule foreach 'the command'", 
            "title": "Dealing with git submodules"
        }, 
        {
            "location": "/dev/iface/", 
            "text": "Wire Cell uses Interfaces to access major components.\n\n\nOverview of Interfaces\n\n\nWire Cell has a number of high-level concepts which are implemented as\nC++ \"Interface\" classes.  Such classes expose only methods which take\nor return either Plain Old Data (POD) or instances from the\n\nWire Cell Data\n package.\n\n\nThe reason for this additional layer is to provide a decoupling\nbetween the different Wire Cell packages and to allow one to set\nactual implementations at the application layer.  This allows for\ncompeting implementations to be swapped in a transparent manner.  For\nexample, one may have a wire geometry that comes from a parameterized\nmodel that generates wire placements or one may have a detailed as-is\nsurvey where each wire is painstakingly described and stored.  The\ncode that uses such a geometry doesn't care and instead accesses\nwhatever the application layer gives it via the \nIWireGeometry\n\ninterface.\n\n\nA concrete implementation may present multiple interfaces.  For\nexample the \nGeomDataSource\n from the\n\nWire Cell Nav\n package\nprovides both \nIWireGeometry\n and \nIWireDatabase\n interfaces.\n\n\nProviding Interfaces\n\n\nInterface classes provide a mechanism to keep packages independent and\nloosely coupled.  It does this by having code depend only on the\ngeneric interface classes and not on the concrete implementations.  \n\n\nIt is possible (and easy) to violate paradigm and end up back with\ntightly coupled packages and code.  This unwanted tight coupling can\nstill occur if the code that produces the concrete implementation of\nan interface is intermixed with the code that consumes the interface.\n\n\nTo combat this one should layer the packages so that a higher\napplication layer is responsible for creating the concrete\nimplementations of interfaces as well as the consumer code (which may\nalso be accessed through interfaces).\n\n\nSpecifically, to maintain this separation one should place any\n\napps/*.cxx\n and \ntests/*.cxx\n main programs which create concrete\nimplementations of interfaces in a package other than the one that\nholds the generic \nsrc/*.cxx\n library files.\n\n\nContext\n\n\nThere are various important interfaces that most all of Wire Cell code\nwill require.  It is thus convenient to bundle access to these into a\nsingle interface called the \nIContext\n.  This simplifies high-level\napplication code as the code for creating and initializing a specific\ncontext can be provided as a high-level library.  For example, all\ngeometry and readout data may come from some domain.  One example is\nif the input to Wire Cell originates from\n\nWire Cell SST\n files.\nHigh-level application code can depend on SST, produce an SST-based\ncontext and feed its content to the Wire Cell code as generic\ninterfaces.\n\n\nExample\n\n\nThe figure below gives a hypothetical example.  At the top are the\nWire Cell interfaces.  In the middle are the concrete implementations\nof these interfaces.  At the very bottom are (paradoxically)\nhigh-level application components which aggregate concrete\nimplementations together in order to drive the program.  Shown is an\nexample of how Wire Cell and LArSoft might integrate.  A\n\nwire-cell-larsoft\n component would provide concrete implementations\nof Wire Cell interfaces using code that depends on facilities from\nLArSoft.  A high-level (at the bottom) \"application\" (an Art module)\nwould tie together the interfaces implemented by LArSoft code and the\nWire Cell implementation in order to run in an Art job.", 
            "title": "Interfaces"
        }, 
        {
            "location": "/dev/iface/#overview-of-interfaces", 
            "text": "Wire Cell has a number of high-level concepts which are implemented as\nC++ \"Interface\" classes.  Such classes expose only methods which take\nor return either Plain Old Data (POD) or instances from the Wire Cell Data  package.  The reason for this additional layer is to provide a decoupling\nbetween the different Wire Cell packages and to allow one to set\nactual implementations at the application layer.  This allows for\ncompeting implementations to be swapped in a transparent manner.  For\nexample, one may have a wire geometry that comes from a parameterized\nmodel that generates wire placements or one may have a detailed as-is\nsurvey where each wire is painstakingly described and stored.  The\ncode that uses such a geometry doesn't care and instead accesses\nwhatever the application layer gives it via the  IWireGeometry \ninterface.  A concrete implementation may present multiple interfaces.  For\nexample the  GeomDataSource  from the Wire Cell Nav  package\nprovides both  IWireGeometry  and  IWireDatabase  interfaces.", 
            "title": "Overview of Interfaces"
        }, 
        {
            "location": "/dev/iface/#providing-interfaces", 
            "text": "Interface classes provide a mechanism to keep packages independent and\nloosely coupled.  It does this by having code depend only on the\ngeneric interface classes and not on the concrete implementations.    It is possible (and easy) to violate paradigm and end up back with\ntightly coupled packages and code.  This unwanted tight coupling can\nstill occur if the code that produces the concrete implementation of\nan interface is intermixed with the code that consumes the interface.  To combat this one should layer the packages so that a higher\napplication layer is responsible for creating the concrete\nimplementations of interfaces as well as the consumer code (which may\nalso be accessed through interfaces).  Specifically, to maintain this separation one should place any apps/*.cxx  and  tests/*.cxx  main programs which create concrete\nimplementations of interfaces in a package other than the one that\nholds the generic  src/*.cxx  library files.", 
            "title": "Providing Interfaces"
        }, 
        {
            "location": "/dev/iface/#context", 
            "text": "There are various important interfaces that most all of Wire Cell code\nwill require.  It is thus convenient to bundle access to these into a\nsingle interface called the  IContext .  This simplifies high-level\napplication code as the code for creating and initializing a specific\ncontext can be provided as a high-level library.  For example, all\ngeometry and readout data may come from some domain.  One example is\nif the input to Wire Cell originates from Wire Cell SST  files.\nHigh-level application code can depend on SST, produce an SST-based\ncontext and feed its content to the Wire Cell code as generic\ninterfaces.", 
            "title": "Context"
        }, 
        {
            "location": "/dev/iface/#example", 
            "text": "The figure below gives a hypothetical example.  At the top are the\nWire Cell interfaces.  In the middle are the concrete implementations\nof these interfaces.  At the very bottom are (paradoxically)\nhigh-level application components which aggregate concrete\nimplementations together in order to drive the program.  Shown is an\nexample of how Wire Cell and LArSoft might integrate.  A wire-cell-larsoft  component would provide concrete implementations\nof Wire Cell interfaces using code that depends on facilities from\nLArSoft.  A high-level (at the bottom) \"application\" (an Art module)\nwould tie together the interfaces implemented by LArSoft code and the\nWire Cell implementation in order to run in an Art job.", 
            "title": "Example"
        }, 
        {
            "location": "/dev/data/", 
            "text": "Wire Cell has a simple ROOT I/O persistency module.  \n\n\nSchema\n\n\nThe data is saved to several ROOT TFiles is shown in the following\nfigure.  Refer to the \nterms\n section for a nomenclature.\n\n\n\n\n([\nPNG\n], [\nPDF\n], [\nDOT\n] and [\nSVG\n])\n\n\nGeneralities\n\n\nTo store the data into a ROOT file we must take care of ownership and\nreferences explicitly.  In general this is handled by representing\nownership as an array of objects and references as an index into this\narray.\n\n\nThere are three trees: Geometry, Channel and Cell.\n\n\nGeometry\n\n\nThe geometry is saved into a tree with a single entry.  There are\nthree owning arrays, \nWireStore\n, \nPointStore\n and \nTilingStore\n\nowning:\n\n\n\n\n\n\nWire\n with associated channel ID number (referred to in the\nChannel data tree) and two end points\n\n\n\n\n\n\nPoint\n all 3d Points referred to by other objects.\n\n\n\n\n\n\nCell\n associates a Wire via it's index (\nwid\n) with a center\n  point and an (ordered) array of points that make up the corners of\n  the cell.\n\n\n\n\n\n\nChannel\n\n\nInformation about charge read out from all channels in a frame.  One\nentry in this branch spans an entire readout frame.\n\n\n\n\n\n\nChannelStore\n holds all channel data for the frame\n\n\n\n\n\n\nChannelSlice\n associates a time bin \ntbin\n that counts relative\nto the start of the frame with a collection of read out channel\ncharges.  A negative charge is undefined.\n\n\n\n\n\n\nChannelCharge\n associates a channel ID with a charge.\n\n\n\n\n\n\nCell\n\n\nThe Cell branch holds associations between charge and cells and groups\nof cells.  This branch may hold MC truth value or reconstruction.\n\n\n\n\n\n\nCellCharge\n associates a cell ID, which is an index into the\n  \nTilingStore\n with a charge.  A negative charge is undefined.\n\n\n\n\n\n\nBlob\n owns an array of \nCellCharge\n.  The \ntechnique\n is a user\n  defined string to label the origin of the blob (eg, \"simtruth\" or\n  maybe \"2dtoyreco\", etc).  The \ntbin\n counts the time bin from the\n  beginning of the frame, the \nqtot\n is some measure of the charge for\n  the blob as a whole (and may not necessarily be the sum of the\n  charge on the individual cells).  The \nquality\nis a\n  \ntechnique\n-specific measure of quality and finally the array of\n  cell charge.\n\n\n\n\n\n\nBlobCluster\n is a (non-owning) association of blobs.  This may be\n  used to collect blobs together within one time slice or may be used\n  to collect them together across multiple time slices such as to form\n  the blobs contributing to a track or a shower.  Blobs are referenced\n  by their index into the frame's \nBlobStore\n.  All available\n  \nBlobClusters\n are stored in the \nClusterStore", 
            "title": "Persistency"
        }, 
        {
            "location": "/dev/data/#schema", 
            "text": "The data is saved to several ROOT TFiles is shown in the following\nfigure.  Refer to the  terms  section for a nomenclature.   ([ PNG ], [ PDF ], [ DOT ] and [ SVG ])", 
            "title": "Schema"
        }, 
        {
            "location": "/dev/data/#generalities", 
            "text": "To store the data into a ROOT file we must take care of ownership and\nreferences explicitly.  In general this is handled by representing\nownership as an array of objects and references as an index into this\narray.  There are three trees: Geometry, Channel and Cell.", 
            "title": "Generalities"
        }, 
        {
            "location": "/dev/data/#geometry", 
            "text": "The geometry is saved into a tree with a single entry.  There are\nthree owning arrays,  WireStore ,  PointStore  and  TilingStore \nowning:    Wire  with associated channel ID number (referred to in the\nChannel data tree) and two end points    Point  all 3d Points referred to by other objects.    Cell  associates a Wire via it's index ( wid ) with a center\n  point and an (ordered) array of points that make up the corners of\n  the cell.", 
            "title": "Geometry"
        }, 
        {
            "location": "/dev/data/#channel", 
            "text": "Information about charge read out from all channels in a frame.  One\nentry in this branch spans an entire readout frame.    ChannelStore  holds all channel data for the frame    ChannelSlice  associates a time bin  tbin  that counts relative\nto the start of the frame with a collection of read out channel\ncharges.  A negative charge is undefined.    ChannelCharge  associates a channel ID with a charge.", 
            "title": "Channel"
        }, 
        {
            "location": "/dev/data/#cell", 
            "text": "The Cell branch holds associations between charge and cells and groups\nof cells.  This branch may hold MC truth value or reconstruction.    CellCharge  associates a cell ID, which is an index into the\n   TilingStore  with a charge.  A negative charge is undefined.    Blob  owns an array of  CellCharge .  The  technique  is a user\n  defined string to label the origin of the blob (eg, \"simtruth\" or\n  maybe \"2dtoyreco\", etc).  The  tbin  counts the time bin from the\n  beginning of the frame, the  qtot  is some measure of the charge for\n  the blob as a whole (and may not necessarily be the sum of the\n  charge on the individual cells).  The  quality is a\n   technique -specific measure of quality and finally the array of\n  cell charge.    BlobCluster  is a (non-owning) association of blobs.  This may be\n  used to collect blobs together within one time slice or may be used\n  to collect them together across multiple time slices such as to form\n  the blobs contributing to a track or a shower.  Blobs are referenced\n  by their index into the frame's  BlobStore .  All available\n   BlobClusters  are stored in the  ClusterStore", 
            "title": "Cell"
        }, 
        {
            "location": "/dev/test/", 
            "text": "Tests\n\n\nTests go under the \ntest/\n (or \ntests/\n) sub-directory of the package.  There are two types, C++ and Python.  In both cases, only files that begin with \"\ntest_*\n\" will be considered tests.  Tests are automatically run as part of the build procedure (fixme: just C++ ones are automatic right now) and will be rerun when they or code they depend on changes.   When tests are run by the build the \nstdout/stderr\n is typically captured.  You can run them manually to observe any print statements.  Tests are not installed but left in the \"\nbuild/\n\" (or sometimes \"\ntmp/\n\") output directory.\n\n\nHere are a few general guidelines for writing tests:\n\n\n\n\nwrite many tests\n\n\nwrite tests as fine grained as convenient\n\n\nthe best tests are written before or while the code they test is being written\n\n\ntest code does need not be \"pretty\", it will never be called from anywhere else\n\n\ntests should run quickly\n\n\ndo use contrived data or mocked code to provide a bit of test code it's needed input or code support\n\n\n\n\nC++ tests\n\n\nWriting a C++ test is to write a \nmain()\n program which takes \nno arguments\n.  If a test fails, either let it crash the test program or call \nexit(1)\n.\n\n\nYou can explicitly run C++ test programs.  When they are run as part of the build, their full path is printed.  When run automatically, waf takes care of setting up their environment so that their libraries are found.  When run manually you will have to assure this.  The simplest way is to \nwaf install\n\" the package first.\n\n\n$ waf\n...\nexecution summary\n  tests that pass 3/4\n    /home/bviren/projects/wire-cell/top/build/data/test_construct\n    /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource\n    /home/bviren/projects/wire-cell/top/build/sst/tgeomdatasource\n  tests that fail 1/4\n    /home/bviren/projects/wire-cell/top/build/data/test_fail\n'build' finished successfully\n\n$ waf install\n\n$ /home/bviren/projects/wire-cell/top/build/sst/test_sst_geomdatasource\nWire: 0 plane=1 index=0\nWire: 0 plane=1 index=1\nWire: 0 plane=1 index=2\n...", 
            "title": "Testing"
        }, 
        {
            "location": "/dev/test/#tests", 
            "text": "Tests go under the  test/  (or  tests/ ) sub-directory of the package.  There are two types, C++ and Python.  In both cases, only files that begin with \" test_* \" will be considered tests.  Tests are automatically run as part of the build procedure (fixme: just C++ ones are automatic right now) and will be rerun when they or code they depend on changes.   When tests are run by the build the  stdout/stderr  is typically captured.  You can run them manually to observe any print statements.  Tests are not installed but left in the \" build/ \" (or sometimes \" tmp/ \") output directory.  Here are a few general guidelines for writing tests:   write many tests  write tests as fine grained as convenient  the best tests are written before or while the code they test is being written  test code does need not be \"pretty\", it will never be called from anywhere else  tests should run quickly  do use contrived data or mocked code to provide a bit of test code it's needed input or code support", 
            "title": "Tests"
        }, 
        {
            "location": "/dev/test/#c-tests", 
            "text": "Writing a C++ test is to write a  main()  program which takes  no arguments .  If a test fails, either let it crash the test program or call  exit(1) .  You can explicitly run C++ test programs.  When they are run as part of the build, their full path is printed.  When run automatically, waf takes care of setting up their environment so that their libraries are found.  When run manually you will have to assure this.  The simplest way is to  waf install \" the package first.  $ waf\n...\nexecution summary\n  tests that pass 3/4\n    /home/bviren/projects/wire-cell/top/build/data/test_construct\n    /home/bviren/projects/wire-cell/top/build/nav/test_geomdatasource\n    /home/bviren/projects/wire-cell/top/build/sst/tgeomdatasource\n  tests that fail 1/4\n    /home/bviren/projects/wire-cell/top/build/data/test_fail\n'build' finished successfully\n\n$ waf install\n\n$ /home/bviren/projects/wire-cell/top/build/sst/test_sst_geomdatasource\nWire: 0 plane=1 index=0\nWire: 0 plane=1 index=1\nWire: 0 plane=1 index=2\n...", 
            "title": "C++ tests"
        }, 
        {
            "location": "/alg/cell/", 
            "text": "", 
            "title": "Making Cells"
        }, 
        {
            "location": "/alg/blob/", 
            "text": "", 
            "title": "Blob Reconstruction"
        }, 
        {
            "location": "/viz/bee/", 
            "text": "Introduction to BEE\n\n\nRequirements\n\n\nBasic Interactions\n\n\nAdvanced Interactions\n\n\nShow and Overlay results from different algorithms\n\n\n\n\n\n\nHotkeys\n\n\n\n\n\n\nIntroduction to BEE\n\n\nDisplaying 3D reconstruction results is difficult.\nOften it requires installation of some platform-dependent programs and downloading some pre-formated data.\nFor most physicists, it's too much effort (\"Just show me the results!\")\n\n\nBEE\n is a web-based application intended to solve this problem, and brings the interactive 3D world to the physicists. Some of the features include:\n\n\n\n\nNo installation\n : Just go to \nthe BEE homepage\n.\n\n\nCross-platform\n : Runs everywhere with \na modern web browser that supports WebGL\n, including mobile devices.\n\n\nEasy share\n: Each event has its own url that can be shared with anyone in the world.\n\n\nInteractive\n : Unleashes the power of WebGL with mouse and keyboard.\n\n\nCross experiments\n: Supports most LArTPC detector geometries.\n\n\nReady for analysis\n : User uploads, multiple algorithms, MC truth, customizable overlay, etc.\n\n\n\n\nRequirements\n\n\nThe only requirements to run BEE are:\n\n\n\n\nA modern web browser that supports WebGL. (\nWill my browser work?\n)\n  We recommend \nGoogle Chrome\n for the best experience.\n\n\nAn internet connection.\n\n\nA relatively good graphic card. A discrete GPU greatly enhances the performance.\n\n\n\n\nBasic Interactions\n\n\nThe following table summarizes the basic interactions with BEE on different devices:\n\n\n\n\n\n\n\n\nAction\n\n\nMouse\n\n\nKeyboard\n\n\nTouch\n\n\n\n\n\n\n\n\n\n\nRotate\n\n\nLeft button drag\n\n\n\n\nOne-finger touch\n\n\n\n\n\n\nPan\n\n\nRight button drag\n\n\nLeft / Right / Up / Down\n\n\nThree-finger swipe\n\n\n\n\n\n\nZoom in / Zoom out\n\n\nMouse wheel\n\n\nShift+Up / Shift+Down\n\n\nPinch \n Zoom\n\n\n\n\n\n\n\n\nAdvanced Interactions\n\n\nShow and Overlay results from different algorithms\n\n\nBee supports any algorithms that produce a set of 3D space points (with or without charge). In the right control panel, the \"Recon\" folder shows the list of algorithms that Bee can load. By default, only the first one is loaded and its space points are displayed on screen. To show others:\n\n\n\n\nClick on the name of the algorithm. If it is not loaded yet, Bee will download its space points from the server. \n\n\nNotice that the left panel now shows the name, size, opacity and color of the current actively selected algorithm.\n\n\nIncrease the opacity until it is displayed on screen.\n\n\nYou can now switch to other algorithms to adjust their opacity so that they can be overlayed.\n\n\nYou may need to uncheck the \"Show Charge\" checkbox (on the right panel) so that the algorithm can be represented by a single color.\n\n\n\n\nHotkeys\n\n\nUsers may find it convenient that most actions in BEE can be achieved using keyboard shortcuts.\nThe full list of hot-keys can be found through \"Menu -\n View -\n Hotkey List\", and is also summarized below:\n\n\n\n    \n\n      \n\n        \nCommand\nHotkey\n\n        \nCommand\nHotkey\n\n      \n\n    \n\n    \n\n      \n\n        \nToggle MC\nm\n\n        \nToggle Charge\nq\n\n      \n\n      \n\n        \nNext Event\nShift+n\n\n        \nPrev Event\nShift+p\n\n      \n\n      \n\n        \nNext Recon\n]\n\n        \nPrev Recon\n[\n\n      \n\n      \n\n        \nNext Slice\nk\n\n        \nPrev Slice\nj\n\n      \n\n      \n\n        \nNext Flash\n>\n\n        \nPrev Flash\n<\n\n      \n\n      \n\n        \nCenter to Event\nc\n\n        \nReset Camera\nr\n\n      \n\n      \n\n        \nX-U view\nu\n\n        \nX-V view\nv\n\n      \n\n      \n\n        \nX-Z view\nz\n\n        \nX-Y view\nx\n\n      \n\n      \n\n        \nZoom in\nShift+Up\n\n        \nZoom out\nShift+Down\n\n      \n\n      \n\n        \nSelect Recon\n1 - 9\n\n        \nUnselect All\nEsc\n\n      \n\n      \n\n        \nIncrease Opacity\n=\n\n        \nDecrease Opacity\n-\n\n      \n\n      \n\n        \nIncrease Point Size\n+\n\n        \nDecrease Point Size\n_\n\n      \n\n      \n\n        \nRedraw All Points\no\n\n        \nShow FPS\ns", 
            "title": "BEE"
        }, 
        {
            "location": "/viz/bee/#introduction-to-bee", 
            "text": "Displaying 3D reconstruction results is difficult.\nOften it requires installation of some platform-dependent programs and downloading some pre-formated data.\nFor most physicists, it's too much effort (\"Just show me the results!\")  BEE  is a web-based application intended to solve this problem, and brings the interactive 3D world to the physicists. Some of the features include:   No installation  : Just go to  the BEE homepage .  Cross-platform  : Runs everywhere with  a modern web browser that supports WebGL , including mobile devices.  Easy share : Each event has its own url that can be shared with anyone in the world.  Interactive  : Unleashes the power of WebGL with mouse and keyboard.  Cross experiments : Supports most LArTPC detector geometries.  Ready for analysis  : User uploads, multiple algorithms, MC truth, customizable overlay, etc.", 
            "title": "Introduction to BEE"
        }, 
        {
            "location": "/viz/bee/#requirements", 
            "text": "The only requirements to run BEE are:   A modern web browser that supports WebGL. ( Will my browser work? )\n  We recommend  Google Chrome  for the best experience.  An internet connection.  A relatively good graphic card. A discrete GPU greatly enhances the performance.", 
            "title": "Requirements"
        }, 
        {
            "location": "/viz/bee/#basic-interactions", 
            "text": "The following table summarizes the basic interactions with BEE on different devices:     Action  Mouse  Keyboard  Touch      Rotate  Left button drag   One-finger touch    Pan  Right button drag  Left / Right / Up / Down  Three-finger swipe    Zoom in / Zoom out  Mouse wheel  Shift+Up / Shift+Down  Pinch   Zoom", 
            "title": "Basic Interactions"
        }, 
        {
            "location": "/viz/bee/#advanced-interactions", 
            "text": "", 
            "title": "Advanced Interactions"
        }, 
        {
            "location": "/viz/bee/#show-and-overlay-results-from-different-algorithms", 
            "text": "Bee supports any algorithms that produce a set of 3D space points (with or without charge). In the right control panel, the \"Recon\" folder shows the list of algorithms that Bee can load. By default, only the first one is loaded and its space points are displayed on screen. To show others:   Click on the name of the algorithm. If it is not loaded yet, Bee will download its space points from the server.   Notice that the left panel now shows the name, size, opacity and color of the current actively selected algorithm.  Increase the opacity until it is displayed on screen.  You can now switch to other algorithms to adjust their opacity so that they can be overlayed.  You may need to uncheck the \"Show Charge\" checkbox (on the right panel) so that the algorithm can be represented by a single color.", 
            "title": "Show and Overlay results from different algorithms"
        }, 
        {
            "location": "/viz/bee/#hotkeys", 
            "text": "Users may find it convenient that most actions in BEE can be achieved using keyboard shortcuts.\nThe full list of hot-keys can be found through \"Menu -  View -  Hotkey List\", and is also summarized below:  \n     \n       \n         Command Hotkey \n         Command Hotkey \n       \n     \n     \n       \n         Toggle MC m \n         Toggle Charge q \n       \n       \n         Next Event Shift+n \n         Prev Event Shift+p \n       \n       \n         Next Recon ] \n         Prev Recon [ \n       \n       \n         Next Slice k \n         Prev Slice j \n       \n       \n         Next Flash > \n         Prev Flash < \n       \n       \n         Center to Event c \n         Reset Camera r \n       \n       \n         X-U view u \n         X-V view v \n       \n       \n         X-Z view z \n         X-Y view x \n       \n       \n         Zoom in Shift+Up \n         Zoom out Shift+Down \n       \n       \n         Select Recon 1 - 9 \n         Unselect All Esc \n       \n       \n         Increase Opacity = \n         Decrease Opacity - \n       \n       \n         Increase Point Size + \n         Decrease Point Size _ \n       \n       \n         Redraw All Points o \n         Show FPS s", 
            "title": "Hotkeys"
        }, 
        {
            "location": "/viz/uploads/", 
            "text": "JSON Schema\n\n\nUpload File Structure\n\n\nTools\n\n\nConvert Wire-Cell Output to BEE\n\n\nConvert LArSoft Output to BEE\n\n\n\n\n\n\n\n\n\n\nJSON Schema\n\n\nBEE can be used to display results from any algorithms that produce \n3D space points\n.\nAt the core, it parses a JSON file that looks like:\n\n\n{\n    \nrunNo\n    : \n10000007\n,\n    \nsubRunNo\n : \n16\n,\n    \neventNo\n  : \n1501\n,\n    \nx\n        : [1.0, 1.0, 3.0],\n    \ny\n        : [2.0, 3.0, 4.0],\n    \nz\n        : [3.0, 7.0, 4.5],\n    \nq\n        : [3000, 4200, 5600],\n    \ngeom\n     : \nuboone\n,\n    \ntype\n     : \nwire-cell\n\n}\n\n\n\n\nIn the JSON file, only the \nx\n, \ny\n, and \nz\n variables are required, all others are optional.\nTheir descriptions are summarized below:\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\nDefault\n\n\n\n\n\n\n\n\n\n\nx\n\n\narray of x coordinates of the 3D space points [cm]\n\n\n(required)\n\n\n\n\n\n\ny\n\n\narray of y coordinates of the 3D space points [cm]\n\n\n(required)\n\n\n\n\n\n\nz\n\n\narray of z coordinates of the 3D space points [cm]\n\n\n(required)\n\n\n\n\n\n\nq\n\n\narray of charges for the 3D space points [number of electrons]\n\n\n[0,..]\n\n\n\n\n\n\nrunNo\n\n\nDAQ run number\n\n\n0\n\n\n\n\n\n\nsubRunNo\n\n\nDAQ subrun number\n\n\n0\n\n\n\n\n\n\neventNo\n\n\nDAQ event number\n\n\n0\n\n\n\n\n\n\ngeom\n\n\nname of the detector geometry (\"uboone\", \"dune35t\", \"protodune\")\n\n\n\"uboone\"\n\n\n\n\n\n\ntype\n\n\nname of the algorithm\n\n\n\"\"\n\n\n\n\n\n\n\n\nUpload File Structure\n\n\nBEE supports user uploads through drag-and-drop to the dropzone on \nthe BEE homepage\n.\nThe uploaded file must be a \n.zip\n file that contains the following structure\n\n\nmyfile.zip\n\u2514\u2500\u2500 data\n    \u251c\u2500\u2500 0\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 0-myAlg1.json\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 0-myAlg2.json\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 0-myAlg3.json\n    \u251c\u2500\u2500 1\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 1-myAlg1.json\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 1-myAlg1.json\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 1-myAlg1.json\n\n\n\n\n\nor, more specifically:\n\n\n\n\nthe top directory must be named \ndata/\n\n\neach event has its own numbered sub-directory\n\n\neach algorithm has its own JSON file\n\n\nthe JSON file should be named as \n{eventID}-{algName}.json\n\n\nthe event ID should be sequential and start from 0\n\n\n\n\nOnce the directory and files are ready, the \n.zip\n file can be created with any prefered zip compression tools. As an example, in linux, one can create the \nmyfile.zip\n file for upload by running\n\n\nzip -r myfile data\n\n\n\n\nTools\n\n\nConvert Wire-Cell Output to BEE\n\n\nDownload the the two files from \nhere\n, then run\n\n\npython dump_json.py [filename] [alg1 alg2 ...]\n\n\n\n\nThe currently available Wire-Cell algorithms are \nsimple\n, \ncharge\n, \ntrue\n, and \ndeblob\n.\nAt the end of the run, a \nto_upload.zip\n is created and can be drag-to-upload to \nBEE\n\n\nSome notes:\n\n\n\n\nThe default algorithms to run are \nsimple\n and \ncharge\n if not specified\n\n\nThe script expects the ROOT file ending with \n_{eventID}.root\n,\nand will actually run through all files in the same directory that have the same prefix.\n\n\nIf your files are in the same directory but have different prefix,\nyou can use a special syntax \npython dump_json.py 'yourdir/*_*.root' [alg1 alg2 ...]\n. Please don't foget the single quotes.\n\n\n\n\nConvert LArSoft Output to BEE\n\n\nAssuming that you have \nlarsoft\n installed,\n(if not, follow \nhere\n),\nsimply run the following script to convert your larsoft output to BEE\n\n\nlar -c celltree_dune35t.fcl [filename]\n\n\n\n\nor, for MicroBooNE / protoDUNE, change the corresponding \n.fcl\n file to\n\ncelltree_uboone.fcl\n / \ncelltree_protodune.fcl\n.\n\n\nIt will create a \nbee/bee_upload.zip\n file under your working directory.\nYou can then drag-and-drop the zip file to \nBEE\n to view the results\n(and MC tracks).\n\n\nThe \nCellTree\n module is located under \nlarreco/WireCell/\n\nIt works for any larsoft output that contains \nSpace Points\n.\nTo change or add different \nSpacePoint\n algorithms (it supports multiple algorithms),\ncopy the \ncelltree_{detector}.fcl\n file to your working directory\nand modify the line \nSpacePointLabels: [\"pmtrackdc\"]\n to include your favorate algorithms.", 
            "title": "User Uploads"
        }, 
        {
            "location": "/viz/uploads/#json-schema", 
            "text": "BEE can be used to display results from any algorithms that produce  3D space points .\nAt the core, it parses a JSON file that looks like:  {\n     runNo     :  10000007 ,\n     subRunNo  :  16 ,\n     eventNo   :  1501 ,\n     x         : [1.0, 1.0, 3.0],\n     y         : [2.0, 3.0, 4.0],\n     z         : [3.0, 7.0, 4.5],\n     q         : [3000, 4200, 5600],\n     geom      :  uboone ,\n     type      :  wire-cell \n}  In the JSON file, only the  x ,  y , and  z  variables are required, all others are optional.\nTheir descriptions are summarized below:     Name  Description  Default      x  array of x coordinates of the 3D space points [cm]  (required)    y  array of y coordinates of the 3D space points [cm]  (required)    z  array of z coordinates of the 3D space points [cm]  (required)    q  array of charges for the 3D space points [number of electrons]  [0,..]    runNo  DAQ run number  0    subRunNo  DAQ subrun number  0    eventNo  DAQ event number  0    geom  name of the detector geometry (\"uboone\", \"dune35t\", \"protodune\")  \"uboone\"    type  name of the algorithm  \"\"", 
            "title": "JSON Schema"
        }, 
        {
            "location": "/viz/uploads/#upload-file-structure", 
            "text": "BEE supports user uploads through drag-and-drop to the dropzone on  the BEE homepage .\nThe uploaded file must be a  .zip  file that contains the following structure  myfile.zip\n\u2514\u2500\u2500 data\n    \u251c\u2500\u2500 0\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 0-myAlg1.json\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 0-myAlg2.json\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 0-myAlg3.json\n    \u251c\u2500\u2500 1\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 1-myAlg1.json\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 1-myAlg1.json\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 1-myAlg1.json  or, more specifically:   the top directory must be named  data/  each event has its own numbered sub-directory  each algorithm has its own JSON file  the JSON file should be named as  {eventID}-{algName}.json  the event ID should be sequential and start from 0   Once the directory and files are ready, the  .zip  file can be created with any prefered zip compression tools. As an example, in linux, one can create the  myfile.zip  file for upload by running  zip -r myfile data", 
            "title": "Upload File Structure"
        }, 
        {
            "location": "/viz/uploads/#tools", 
            "text": "", 
            "title": "Tools"
        }, 
        {
            "location": "/viz/uploads/#convert-wire-cell-output-to-bee", 
            "text": "Download the the two files from  here , then run  python dump_json.py [filename] [alg1 alg2 ...]  The currently available Wire-Cell algorithms are  simple ,  charge ,  true , and  deblob .\nAt the end of the run, a  to_upload.zip  is created and can be drag-to-upload to  BEE  Some notes:   The default algorithms to run are  simple  and  charge  if not specified  The script expects the ROOT file ending with  _{eventID}.root ,\nand will actually run through all files in the same directory that have the same prefix.  If your files are in the same directory but have different prefix,\nyou can use a special syntax  python dump_json.py 'yourdir/*_*.root' [alg1 alg2 ...] . Please don't foget the single quotes.", 
            "title": "Convert Wire-Cell Output to BEE"
        }, 
        {
            "location": "/viz/uploads/#convert-larsoft-output-to-bee", 
            "text": "Assuming that you have  larsoft  installed,\n(if not, follow  here ),\nsimply run the following script to convert your larsoft output to BEE  lar -c celltree_dune35t.fcl [filename]  or, for MicroBooNE / protoDUNE, change the corresponding  .fcl  file to celltree_uboone.fcl  /  celltree_protodune.fcl .  It will create a  bee/bee_upload.zip  file under your working directory.\nYou can then drag-and-drop the zip file to  BEE  to view the results\n(and MC tracks).  The  CellTree  module is located under  larreco/WireCell/ \nIt works for any larsoft output that contains  Space Points .\nTo change or add different  SpacePoint  algorithms (it supports multiple algorithms),\ncopy the  celltree_{detector}.fcl  file to your working directory\nand modify the line  SpacePointLabels: [\"pmtrackdc\"]  to include your favorate algorithms.", 
            "title": "Convert LArSoft Output to BEE"
        }, 
        {
            "location": "/meta/meta/", 
            "text": "About this site\n\n\nThis site uses MkDocs and is served by GitHub.\n\n\nTo edit\n\n\n$ git clone git@github.com:BNLIF/wire-cell-docs.git\n$ cd wire-cell-docs\n$ emacs\n$ git commit -a -m \n...\n\n$ git push\n\n\n\n\nTo preview\n\n\n$ mkdocs serve\nINFO    -  Building documentation...\n[I 150708 17:57:26 server:271] Serving on http://127.0.0.1:8000\n[I 150708 17:57:26 handlers:58] Start watching changes\n[I 150708 17:57:26 handlers:60] Start detecting changes\n\n\n\n\nClick on the link to view the result in your browser.  As you continue\nto edit the server should notice the change, regenerate and trigger\nyour browser to refresh.\n\n\nTo deploy\n\n\n$ mkdocs gh-deploy --clean\n\n\n\n\nAfter a brief moment this will update \nthe main docs site\n.", 
            "title": "About"
        }, 
        {
            "location": "/meta/meta/#about-this-site", 
            "text": "This site uses MkDocs and is served by GitHub.  To edit  $ git clone git@github.com:BNLIF/wire-cell-docs.git\n$ cd wire-cell-docs\n$ emacs\n$ git commit -a -m  ... \n$ git push  To preview  $ mkdocs serve\nINFO    -  Building documentation...\n[I 150708 17:57:26 server:271] Serving on http://127.0.0.1:8000\n[I 150708 17:57:26 handlers:58] Start watching changes\n[I 150708 17:57:26 handlers:60] Start detecting changes  Click on the link to view the result in your browser.  As you continue\nto edit the server should notice the change, regenerate and trigger\nyour browser to refresh.  To deploy  $ mkdocs gh-deploy --clean  After a brief moment this will update  the main docs site .", 
            "title": "About this site"
        }
    ]
}